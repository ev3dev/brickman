<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="DBusGLib" version="1.0"/>
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <namespace name="NetworkManager"
             version="1.0"
             shared-library="libnm-util.so.2"
             c:identifier-prefixes="NM"
             c:symbol-prefixes="nm_">
    <bitfield name="80211ApFlags" c:type="NM80211ApFlags">
      <doc xml:whitespace="preserve">802.11 access point flags.</doc>
      <member name="none" value="0" c:identifier="NM_802_11_AP_FLAGS_NONE"/>
      <member name="privacy"
              value="1"
              c:identifier="NM_802_11_AP_FLAGS_PRIVACY"/>
    </bitfield>
    <bitfield name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags">
      <doc xml:whitespace="preserve">802.11 access point security and authentication flags.  These flags describe
the current security requirements of an access point as determined from the
access point's beacon.</doc>
      <member name="none" value="0" c:identifier="NM_802_11_AP_SEC_NONE"/>
      <member name="pair_wep40"
              value="1"
              c:identifier="NM_802_11_AP_SEC_PAIR_WEP40"/>
      <member name="pair_wep104"
              value="2"
              c:identifier="NM_802_11_AP_SEC_PAIR_WEP104"/>
      <member name="pair_tkip"
              value="4"
              c:identifier="NM_802_11_AP_SEC_PAIR_TKIP"/>
      <member name="pair_ccmp"
              value="8"
              c:identifier="NM_802_11_AP_SEC_PAIR_CCMP"/>
      <member name="group_wep40"
              value="16"
              c:identifier="NM_802_11_AP_SEC_GROUP_WEP40"/>
      <member name="group_wep104"
              value="32"
              c:identifier="NM_802_11_AP_SEC_GROUP_WEP104"/>
      <member name="group_tkip"
              value="64"
              c:identifier="NM_802_11_AP_SEC_GROUP_TKIP"/>
      <member name="group_ccmp"
              value="128"
              c:identifier="NM_802_11_AP_SEC_GROUP_CCMP"/>
      <member name="key_mgmt_psk"
              value="256"
              c:identifier="NM_802_11_AP_SEC_KEY_MGMT_PSK"/>
      <member name="key_mgmt_802_1x"
              value="512"
              c:identifier="NM_802_11_AP_SEC_KEY_MGMT_802_1X"/>
    </bitfield>
    <enumeration name="80211Mode" c:type="NM80211Mode">
      <doc xml:whitespace="preserve">Indicates the 802.11 mode an access point or device is currently in.</doc>
      <member name="unknown" value="0" c:identifier="NM_802_11_MODE_UNKNOWN"/>
      <member name="adhoc" value="1" c:identifier="NM_802_11_MODE_ADHOC"/>
      <member name="infra" value="2" c:identifier="NM_802_11_MODE_INFRA"/>
    </enumeration>
    <enumeration name="ActiveConnectionState" c:type="NMActiveConnectionState">
      <doc xml:whitespace="preserve">#NMActiveConnectionState values indicate the state of a connection to a
specific network while it is starting, connected, or disconnecting from that
network.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_UNKNOWN"/>
      <member name="activating"
              value="1"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_ACTIVATING"/>
      <member name="activated"
              value="2"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_ACTIVATED"/>
      <member name="deactivating"
              value="3"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_DEACTIVATING"/>
    </enumeration>
    <bitfield name="BluetoothCapabilities" c:type="NMBluetoothCapabilities">
      <doc xml:whitespace="preserve">#NMBluetoothCapabilities values indicate the usable capabilities of a
Bluetooth device.</doc>
      <member name="none" value="0" c:identifier="NM_BT_CAPABILITY_NONE"/>
      <member name="dun" value="1" c:identifier="NM_BT_CAPABILITY_DUN"/>
      <member name="nap" value="2" c:identifier="NM_BT_CAPABILITY_NAP"/>
    </bitfield>
    <constant name="CONNECTION_PATH" value="path" c:type="NM_CONNECTION_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Connection"
           c:symbol-prefix="connection"
           c:type="NMConnection"
           parent="GObject.Object"
           glib:type-name="NMConnection"
           glib:get-type="nm_connection_get_type"
           glib:type-struct="ConnectionClass">
      <doc xml:whitespace="preserve">The NMConnection struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <constructor name="new" c:identifier="nm_connection_new">
        <doc xml:whitespace="preserve">Creates a new #NMConnection object with no #NMSetting objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMConnection object</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_hash"
                   c:identifier="nm_connection_new_from_hash"
                   throws="1">
        <doc xml:whitespace="preserve">Creates a new #NMConnection from a hash table describing the connection.  See
nm_connection_to_hash() for a description of the expected hash table.

from the values in the hash table, or NULL if the connection failed to
validate</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #NMConnection object, populated with settings created</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GHashTable describing the connection</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="create_setting"
                c:identifier="nm_connection_create_setting">
        <doc xml:whitespace="preserve">Create a new #NMSetting object of the desired type, given a setting name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new setting object, or NULL if the setting name was unknown</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a setting name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_setting_type"
                c:identifier="nm_connection_lookup_setting_type">
        <doc xml:whitespace="preserve">Returns the #GType of the setting's class for a given setting name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType of the setting's class</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a setting name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_setting_type_by_quark"
                c:identifier="nm_connection_lookup_setting_type_by_quark">
        <doc xml:whitespace="preserve">Returns the #GType of the setting's class for a given setting error quark.
Useful for figuring out which setting a returned error is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType of the setting's class</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="error_quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">a setting error quark</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="secrets_updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="setting" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_setting" c:identifier="nm_connection_add_setting">
        <doc xml:whitespace="preserve">Adds a #NMSetting to the connection, replacing any previous #NMSetting of the
same name which has previously been added to the #NMConnection.  The
connection takes ownership of the #NMSetting object and does not increase
the setting object's reference count.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="setting" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #NMSetting to add to the connection object</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_secrets" c:identifier="nm_connection_clear_secrets">
        <doc xml:whitespace="preserve">Clears and frees any secrets that may be stored in the connection, to avoid
keeping secret data in memory when not needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_secrets_with_flags"
              c:identifier="nm_connection_clear_secrets_with_flags">
        <doc xml:whitespace="preserve">Clears and frees secrets determined by @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">function to be called to determine whether a specific secret should be cleared or not</doc>
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-supplied data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="nm_connection_compare">
        <doc xml:whitespace="preserve">Compares two #NMConnection objects for similarity, with comparison behavior
modified by a set of flags.  See nm_setting_compare() for a description of
each flag's behavior.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the comparison succeeds, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">a second #NMConnection to compare with the first</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="diff" c:identifier="nm_connection_diff">
        <doc xml:whitespace="preserve">Compares two #NMConnection objects for similarity, with comparison behavior
modified by a set of flags.  See nm_setting_compare() for a description of
each flag's behavior.  If the connections differ, settings and keys within
each setting that differ are added to the returned @out_settings hash table.
No values are returned, only key names.

not</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connections contain the same values, %FALSE if they do</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">a second #NMConnection to compare with the first</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
          <parameter name="out_settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">if the connections differ, on return a hash table mapping setting names to second-level GHashTable (utf8 to guint32), which contains the key names that differ mapped to one or more of %NMSettingDiffResult as a bitfield</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="nm_connection_dump">
        <doc xml:whitespace="preserve">Print the connection to stdout.  For debugging purposes ONLY, should NOT
be used for serialization of the connection or machine-parsed in any way. The
output format is not guaranteed to be stable and may change at any time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="duplicate" c:identifier="nm_connection_duplicate">
        <doc xml:whitespace="preserve">Duplicates a #NMConnection.

as the source #NMConnection</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #NMConnection containing the same settings and properties</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
      </method>
      <method name="for_each_setting_value"
              c:identifier="nm_connection_for_each_setting_value">
        <doc xml:whitespace="preserve">Iterates over the properties of each #NMSetting object in the #NMConnection,
calling the supplied user function for each property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">user-supplied function called for each setting's property</doc>
            <type name="SettingValueIterFn" c:type="NMSettingValueIterFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func at each invocation</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_connection_get_id">
        <doc xml:whitespace="preserve">A shortcut to return the ID from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the ID from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_path" c:identifier="nm_connection_get_path">
        <doc xml:whitespace="preserve">Returns the connection's D-Bus path.

nm_connection_set_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the D-Bus path of the connection, previously set by a call to</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_setting" c:identifier="nm_connection_get_setting">
        <doc xml:whitespace="preserve">Gets the #NMSetting with the given #GType, if one has been previously added
to the #NMConnection.

added to the #NMConnection</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSetting, or NULL if no setting of that type was previously</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of the setting object to return</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_setting_802_1x"
              c:identifier="nm_connection_get_setting_802_1x">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSetting8021x the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSetting8021x if the connection contains one, otherwise NULL</doc>
          <type name="Setting8021x" c:type="NMSetting8021x*"/>
        </return-value>
      </method>
      <method name="get_setting_bluetooth"
              c:identifier="nm_connection_get_setting_bluetooth">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingBluetooth the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingBluetooth if the connection contains one, otherwise NULL</doc>
          <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
        </return-value>
      </method>
      <method name="get_setting_bond"
              c:identifier="nm_connection_get_setting_bond">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingBond the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingBond if the connection contains one, otherwise NULL</doc>
          <type name="SettingBond" c:type="NMSettingBond*"/>
        </return-value>
      </method>
      <method name="get_setting_by_name"
              c:identifier="nm_connection_get_setting_by_name">
        <doc xml:whitespace="preserve">Gets the #NMSetting with the given name, if one has been previously added
the the #NMConnection.

added to the #NMConnection</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSetting, or NULL if no setting with that name was previously</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a setting name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_setting_cdma"
              c:identifier="nm_connection_get_setting_cdma">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingCdma the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingCdma if the connection contains one, otherwise NULL</doc>
          <type name="SettingCdma" c:type="NMSettingCdma*"/>
        </return-value>
      </method>
      <method name="get_setting_connection"
              c:identifier="nm_connection_get_setting_connection">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingConnection the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingConnection if the connection contains one, otherwise NULL</doc>
          <type name="SettingConnection" c:type="NMSettingConnection*"/>
        </return-value>
      </method>
      <method name="get_setting_gsm"
              c:identifier="nm_connection_get_setting_gsm">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingGsm the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingGsm if the connection contains one, otherwise NULL</doc>
          <type name="SettingGsm" c:type="NMSettingGsm*"/>
        </return-value>
      </method>
      <method name="get_setting_infiniband"
              c:identifier="nm_connection_get_setting_infiniband">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingInfiniband the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingInfiniband if the connection contains one, otherwise NULL</doc>
          <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
        </return-value>
      </method>
      <method name="get_setting_ip4_config"
              c:identifier="nm_connection_get_setting_ip4_config">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingIP4Config the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingIP4Config if the connection contains one, otherwise NULL</doc>
          <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
        </return-value>
      </method>
      <method name="get_setting_ip6_config"
              c:identifier="nm_connection_get_setting_ip6_config">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingIP6Config the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingIP6Config if the connection contains one, otherwise NULL</doc>
          <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
        </return-value>
      </method>
      <method name="get_setting_olpc_mesh"
              c:identifier="nm_connection_get_setting_olpc_mesh">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingOlpcMesh the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingOlpcMesh if the connection contains one, otherwise NULL</doc>
          <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
        </return-value>
      </method>
      <method name="get_setting_ppp"
              c:identifier="nm_connection_get_setting_ppp">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingPPP the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingPPP if the connection contains one, otherwise NULL</doc>
          <type name="SettingPPP" c:type="NMSettingPPP*"/>
        </return-value>
      </method>
      <method name="get_setting_pppoe"
              c:identifier="nm_connection_get_setting_pppoe">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingPPOE the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingPPPOE if the connection contains one, otherwise NULL</doc>
          <type name="SettingPPPOE" c:type="NMSettingPPPOE*"/>
        </return-value>
      </method>
      <method name="get_setting_serial"
              c:identifier="nm_connection_get_setting_serial">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingSerial the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingSerial if the connection contains one, otherwise NULL</doc>
          <type name="SettingSerial" c:type="NMSettingSerial*"/>
        </return-value>
      </method>
      <method name="get_setting_vlan"
              c:identifier="nm_connection_get_setting_vlan">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingVlan the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingVlan if the connection contains one, otherwise NULL</doc>
          <type name="SettingVlan" c:type="NMSettingVlan*"/>
        </return-value>
      </method>
      <method name="get_setting_vpn"
              c:identifier="nm_connection_get_setting_vpn">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingVPN the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingVPN if the connection contains one, otherwise NULL</doc>
          <type name="SettingVPN" c:type="NMSettingVPN*"/>
        </return-value>
      </method>
      <method name="get_setting_wimax"
              c:identifier="nm_connection_get_setting_wimax">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingWimax the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingWimax if the connection contains one, otherwise NULL</doc>
          <type name="SettingWimax" c:type="NMSettingWimax*"/>
        </return-value>
      </method>
      <method name="get_setting_wired"
              c:identifier="nm_connection_get_setting_wired">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingWired the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingWired if the connection contains one, otherwise NULL</doc>
          <type name="SettingWired" c:type="NMSettingWired*"/>
        </return-value>
      </method>
      <method name="get_setting_wireless"
              c:identifier="nm_connection_get_setting_wireless">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingWireless the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingWireless if the connection contains one, otherwise NULL</doc>
          <type name="SettingWireless" c:type="NMSettingWireless*"/>
        </return-value>
      </method>
      <method name="get_setting_wireless_security"
              c:identifier="nm_connection_get_setting_wireless_security">
        <doc xml:whitespace="preserve">A shortcut to return any #NMSettingWirelessSecurity the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an #NMSettingWirelessSecurity if the connection contains one, otherwise NULL</doc>
          <type name="SettingWirelessSecurity"
                c:type="NMSettingWirelessSecurity*"/>
        </return-value>
      </method>
      <method name="get_uuid" c:identifier="nm_connection_get_uuid">
        <doc xml:whitespace="preserve">A shortcut to return the UUID from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the UUID from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_virtual_iface_name"
              c:identifier="nm_connection_get_virtual_iface_name">
        <doc xml:whitespace="preserve">Returns the name of the virtual kernel interface which the connection
needs to use if specified in the settings. This function abstracts all
connection types which require this functionality. For all other
connection types, this function will return NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the kernel interface or NULL</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="is_type" c:identifier="nm_connection_is_type">
        <doc xml:whitespace="preserve">A convenience function to check if the given @connection is a particular
type (ie wired, wifi, ppp, etc). Checks the #NMSettingConnection:type
property of the connection and matches that against @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is of the given @type, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a setting name to check the connection's type against (like %NM_SETTING_WIRELESS_SETTING_NAME or %NM_SETTING_WIRED_SETTING_NAME)</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="need_secrets" c:identifier="nm_connection_need_secrets">
        <doc xml:whitespace="preserve">Returns the name of the first setting object in the connection which would
need secrets to make a successful connection.  The returned hints are only
intended as a guide to what secrets may be required, because in some
circumstances, there is no way to conclusively determine exactly which
secrets are needed.

missing secrets</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the setting name of the #NMSetting object which has invalid or</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="hints"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve"> the address of a pointer to a #GPtrArray, initialized to NULL, which on return points to an allocated #GPtrArray containing the property names of secrets of the #NMSetting which may be required; the caller owns the array and must free the each array element with g_free(), as well as the array itself with g_ptr_array_free()</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="remove_setting"
              c:identifier="nm_connection_remove_setting">
        <doc xml:whitespace="preserve">Removes the #NMSetting with the given #GType from the #NMConnection.  This
operation dereferences the #NMSetting object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of the setting object to remove</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_settings"
              c:identifier="nm_connection_replace_settings"
              throws="1">
        <doc xml:whitespace="preserve">if they were not</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the settings were valid and added to the connection, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="new_settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable of settings</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="nm_connection_set_path">
        <doc xml:whitespace="preserve">Sets the D-Bus path of the connection.  This property is not serialized, and
is only for the reference of the caller.  Sets the #NMConnection:path
property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus path of the connection as given by the settings service which provides the connection</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hash" c:identifier="nm_connection_to_hash">
        <doc xml:whitespace="preserve">Converts the #NMConnection into a #GHashTable describing the connection,
suitable for marshalling over D-Bus or serializing.  The hash table mapping
is string:#GHashTable with each element in the returned hash representing
a #NMSetting object.  The keys are setting object names, and the values
are #GHashTables mapping string:GValue, each of which represents the
properties of the #NMSetting object.

#GHashTable describing the connection, its settings, and each setting's
properties.  The caller owns the hash table and must unref the hash table
with g_hash_table_unref() when it is no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </type>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">hash flags, e.g. %NM_SETTING_HASH_FLAG_ALL</doc>
            <type name="SettingHashFlags" c:type="NMSettingHashFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_secrets"
              c:identifier="nm_connection_update_secrets"
              throws="1">
        <doc xml:whitespace="preserve">Update the specified setting's secrets, given a hash table of secrets
intended for that setting (deserialized from D-Bus for example).  Will also
extract the given setting's secrets hash if given a hash of hashes, as would
be returned from nm_connection_to_hash().  If @setting_name is %NULL, expects
a fully serialized #NMConnection as returned by nm_connection_to_hash() and
will update all secrets from all settings contained in @secrets.

failed (tried to update secrets for a setting that doesn't exist, etc)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the secrets were successfully updated, %FALSE if the update</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the setting object name to which the secrets apply</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="secrets" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable mapping string:#GValue of setting property names and secrets of the given @setting_name</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="nm_connection_verify" throws="1">
        <doc xml:whitespace="preserve">Validates the connection and all its settings.  Each setting's properties
have allowed values, and some values are dependent on other values.  For
example, if a WiFi connection is security enabled, the #NMSettingWireless
setting object's 'security' property must contain the setting name of the
#NMSettingWirelessSecurity object, which must also be present in the 
connection for the connection to be valid.  As another example, the
#NMSettingWired object's 'mac-address' property must be a validly formatted
MAC address.  The returned #GError contains information about which
setting and which property failed validation, and how it failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="path"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection's D-Bus path, used only by the calling process as a record
of the D-Bus path of the connection as provided by a settings service.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="secrets-cleared" when="first">
        <doc xml:whitespace="preserve">The ::secrets-cleared signal is emitted when the secrets of a connection
are cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-updated" when="first">
        <doc xml:whitespace="preserve">The ::secrets-updated signal is emitted when the secrets of a setting
have been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the setting name of the #NMSetting for which secrets were updated</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionClass"
            c:type="NMConnectionClass"
            glib:is-gtype-struct-for="Connection">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="secrets_updated">
        <callback name="secrets_updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="setting" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="ConnectionError"
                 glib:type-name="NMConnectionError"
                 glib:get-type="nm_connection_error_get_type"
                 c:type="NMConnectionError">
      <doc xml:whitespace="preserve">Describes errors that may result from operations involving a #NMConnection.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_CONNECTION_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="ConnectionSettingNotFound"
              value="1"
              c:identifier="NM_CONNECTION_ERROR_CONNECTION_SETTING_NOT_FOUND"
              glib:nick="ConnectionSettingNotFound"/>
      <member name="ConnectionTypeInvalid"
              value="2"
              c:identifier="NM_CONNECTION_ERROR_CONNECTION_TYPE_INVALID"
              glib:nick="ConnectionTypeInvalid"/>
      <member name="SettingNotFound"
              value="3"
              c:identifier="NM_CONNECTION_ERROR_SETTING_NOT_FOUND"
              glib:nick="SettingNotFound"/>
      <function name="quark" c:identifier="nm_connection_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMConnection if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMConnection errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="DBUS_IFACE_SETTINGS"
              value="org.freedesktop.NetworkManager.Settings"
              c:type="NM_DBUS_IFACE_SETTINGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_IFACE_SETTINGS_CONNECTION"
              value="org.freedesktop.NetworkManager.Settings.Connection"
              c:type="NM_DBUS_IFACE_SETTINGS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_IFACE_SETTINGS_CONNECTION_SECRETS"
              value="org.freedesktop.NetworkManager.Settings.Connection.Secrets"
              c:type="NM_DBUS_IFACE_SETTINGS_CONNECTION_SECRETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE"
              value="org.freedesktop.NetworkManager"
              c:type="NM_DBUS_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_VPN"
              value="org.freedesktop.NetworkManager.VPN.Manager"
              c:type="NM_DBUS_INTERFACE_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPN.Connection"
              c:type="NM_DBUS_INTERFACE_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INVALID_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection"
              c:type="NM_DBUS_INVALID_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_NO_ACTIVE_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection"
              c:type="NM_DBUS_NO_ACTIVE_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_NO_VPN_CONNECTIONS"
              value="org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections"
              c:type="NM_DBUS_NO_VPN_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH"
              value="/org/freedesktop/NetworkManager"
              c:type="NM_DBUS_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_AGENT_MANAGER"
              value="/org/freedesktop/NetworkManager/AgentManager"
              c:type="NM_DBUS_PATH_AGENT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SECRET_AGENT"
              value="/org/freedesktop/NetworkManager/SecretAgent"
              c:type="NM_DBUS_PATH_SECRET_AGENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SETTINGS"
              value="/org/freedesktop/NetworkManager/Settings"
              c:type="NM_DBUS_PATH_SETTINGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SETTINGS_CONNECTION"
              value="/org/freedesktop/NetworkManager/Settings/Connection"
              c:type="NM_DBUS_PATH_SETTINGS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_VPN"
              value="/org/freedesktop/NetworkManager/VPN/Manager"
              c:type="NM_DBUS_PATH_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_VPN_CONNECTION"
              value="/org/freedesktop/NetworkManager/VPN/Connection"
              c:type="NM_DBUS_PATH_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_SERVICE"
              value="org.freedesktop.NetworkManager"
              c:type="NM_DBUS_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ALREADY_STARTED"
              value="AlreadyStarted"
              c:type="NM_DBUS_VPN_ALREADY_STARTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ALREADY_STOPPED"
              value="AlreadyStopped"
              c:type="NM_DBUS_VPN_ALREADY_STOPPED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_BAD_ARGUMENTS"
              value="BadArguments"
              c:type="NM_DBUS_VPN_BAD_ARGUMENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_CONNECT_FAILED"
              value="ConnectFailed"
              c:type="NM_DBUS_VPN_SIGNAL_CONNECT_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_IP4_CONFIG"
              value="IP4Config"
              c:type="NM_DBUS_VPN_SIGNAL_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_IP_CONFIG_BAD"
              value="IPConfigBad"
              c:type="NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LAUNCH_FAILED"
              value="LaunchFailed"
              c:type="NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LOGIN_BANNER"
              value="LoginBanner"
              c:type="NM_DBUS_VPN_SIGNAL_LOGIN_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LOGIN_FAILED"
              value="LoginFailed"
              c:type="NM_DBUS_VPN_SIGNAL_LOGIN_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_STATE_CHANGE"
              value="StateChange"
              c:type="NM_DBUS_VPN_SIGNAL_STATE_CHANGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_VPN_CONFIG_BAD"
              value="VPNConfigBad"
              c:type="NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_STARTING_IN_PROGRESS"
              value="StartingInProgress"
              c:type="NM_DBUS_VPN_STARTING_IN_PROGRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_STOPPING_IN_PROGRESS"
              value="StoppingInProgress"
              c:type="NM_DBUS_VPN_STOPPING_IN_PROGRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_WRONG_STATE"
              value="WrongState"
              c:type="NM_DBUS_VPN_WRONG_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <bitfield name="DeviceCapabilities" c:type="NMDeviceCapabilities">
      <doc xml:whitespace="preserve">General device capability flags.</doc>
      <member name="none" value="0" c:identifier="NM_DEVICE_CAP_NONE"/>
      <member name="nm_supported"
              value="1"
              c:identifier="NM_DEVICE_CAP_NM_SUPPORTED"/>
      <member name="carrier_detect"
              value="2"
              c:identifier="NM_DEVICE_CAP_CARRIER_DETECT"/>
    </bitfield>
    <bitfield name="DeviceModemCapabilities"
              c:type="NMDeviceModemCapabilities">
      <doc xml:whitespace="preserve">#NMDeviceModemCapabilities values indicate the generic radio access
technology families a modem device supports.  For more information on the
specific access technologies the device supports use the ModemManager D-Bus
API.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_NONE"/>
      <member name="pots"
              value="1"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_POTS"/>
      <member name="cdma_evdo"
              value="2"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO"/>
      <member name="gsm_umts"
              value="4"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS"/>
      <member name="lte"
              value="8"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_LTE"/>
    </bitfield>
    <enumeration name="DeviceState" c:type="NMDeviceState">
      <member name="unknown" value="0" c:identifier="NM_DEVICE_STATE_UNKNOWN"/>
      <member name="unmanaged"
              value="10"
              c:identifier="NM_DEVICE_STATE_UNMANAGED"/>
      <member name="unavailable"
              value="20"
              c:identifier="NM_DEVICE_STATE_UNAVAILABLE"/>
      <member name="disconnected"
              value="30"
              c:identifier="NM_DEVICE_STATE_DISCONNECTED"/>
      <member name="prepare"
              value="40"
              c:identifier="NM_DEVICE_STATE_PREPARE"/>
      <member name="config" value="50" c:identifier="NM_DEVICE_STATE_CONFIG"/>
      <member name="need_auth"
              value="60"
              c:identifier="NM_DEVICE_STATE_NEED_AUTH"/>
      <member name="ip_config"
              value="70"
              c:identifier="NM_DEVICE_STATE_IP_CONFIG"/>
      <member name="ip_check"
              value="80"
              c:identifier="NM_DEVICE_STATE_IP_CHECK"/>
      <member name="secondaries"
              value="90"
              c:identifier="NM_DEVICE_STATE_SECONDARIES"/>
      <member name="activated"
              value="100"
              c:identifier="NM_DEVICE_STATE_ACTIVATED"/>
      <member name="deactivating"
              value="110"
              c:identifier="NM_DEVICE_STATE_DEACTIVATING"/>
      <member name="failed" value="120" c:identifier="NM_DEVICE_STATE_FAILED"/>
    </enumeration>
    <enumeration name="DeviceStateReason" c:type="NMDeviceStateReason">
      <member name="none"
              value="0"
              c:identifier="NM_DEVICE_STATE_REASON_NONE"/>
      <member name="unknown"
              value="1"
              c:identifier="NM_DEVICE_STATE_REASON_UNKNOWN"/>
      <member name="now_managed"
              value="2"
              c:identifier="NM_DEVICE_STATE_REASON_NOW_MANAGED"/>
      <member name="now_unmanaged"
              value="3"
              c:identifier="NM_DEVICE_STATE_REASON_NOW_UNMANAGED"/>
      <member name="config_failed"
              value="4"
              c:identifier="NM_DEVICE_STATE_REASON_CONFIG_FAILED"/>
      <member name="ip_config_unavailable"
              value="5"
              c:identifier="NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE"/>
      <member name="ip_config_expired"
              value="6"
              c:identifier="NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED"/>
      <member name="no_secrets"
              value="7"
              c:identifier="NM_DEVICE_STATE_REASON_NO_SECRETS"/>
      <member name="supplicant_disconnect"
              value="8"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT"/>
      <member name="supplicant_config_failed"
              value="9"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED"/>
      <member name="supplicant_failed"
              value="10"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED"/>
      <member name="supplicant_timeout"
              value="11"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT"/>
      <member name="ppp_start_failed"
              value="12"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_START_FAILED"/>
      <member name="ppp_disconnect"
              value="13"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_DISCONNECT"/>
      <member name="ppp_failed"
              value="14"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_FAILED"/>
      <member name="dhcp_start_failed"
              value="15"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_START_FAILED"/>
      <member name="dhcp_error"
              value="16"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_ERROR"/>
      <member name="dhcp_failed"
              value="17"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_FAILED"/>
      <member name="shared_start_failed"
              value="18"
              c:identifier="NM_DEVICE_STATE_REASON_SHARED_START_FAILED"/>
      <member name="shared_failed"
              value="19"
              c:identifier="NM_DEVICE_STATE_REASON_SHARED_FAILED"/>
      <member name="autoip_start_failed"
              value="20"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED"/>
      <member name="autoip_error"
              value="21"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_ERROR"/>
      <member name="autoip_failed"
              value="22"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_FAILED"/>
      <member name="modem_busy"
              value="23"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_BUSY"/>
      <member name="modem_no_dial_tone"
              value="24"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE"/>
      <member name="modem_no_carrier"
              value="25"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER"/>
      <member name="modem_dial_timeout"
              value="26"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT"/>
      <member name="modem_dial_failed"
              value="27"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED"/>
      <member name="modem_init_failed"
              value="28"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED"/>
      <member name="gsm_apn_failed"
              value="29"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_APN_FAILED"/>
      <member name="gsm_registration_not_searching"
              value="30"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING"/>
      <member name="gsm_registration_denied"
              value="31"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED"/>
      <member name="gsm_registration_timeout"
              value="32"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT"/>
      <member name="gsm_registration_failed"
              value="33"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED"/>
      <member name="gsm_pin_check_failed"
              value="34"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED"/>
      <member name="firmware_missing"
              value="35"
              c:identifier="NM_DEVICE_STATE_REASON_FIRMWARE_MISSING"/>
      <member name="removed"
              value="36"
              c:identifier="NM_DEVICE_STATE_REASON_REMOVED"/>
      <member name="sleeping"
              value="37"
              c:identifier="NM_DEVICE_STATE_REASON_SLEEPING"/>
      <member name="connection_removed"
              value="38"
              c:identifier="NM_DEVICE_STATE_REASON_CONNECTION_REMOVED"/>
      <member name="user_requested"
              value="39"
              c:identifier="NM_DEVICE_STATE_REASON_USER_REQUESTED"/>
      <member name="carrier"
              value="40"
              c:identifier="NM_DEVICE_STATE_REASON_CARRIER"/>
      <member name="connection_assumed"
              value="41"
              c:identifier="NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED"/>
      <member name="supplicant_available"
              value="42"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE"/>
      <member name="modem_not_found"
              value="43"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND"/>
      <member name="bt_failed"
              value="44"
              c:identifier="NM_DEVICE_STATE_REASON_BT_FAILED"/>
      <member name="gsm_sim_not_inserted"
              value="45"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED"/>
      <member name="gsm_sim_pin_required"
              value="46"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED"/>
      <member name="gsm_sim_puk_required"
              value="47"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED"/>
      <member name="gsm_sim_wrong"
              value="48"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_WRONG"/>
      <member name="infiniband_mode"
              value="49"
              c:identifier="NM_DEVICE_STATE_REASON_INFINIBAND_MODE"/>
      <member name="dependency_failed"
              value="50"
              c:identifier="NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED"/>
      <member name="last"
              value="65535"
              c:identifier="NM_DEVICE_STATE_REASON_LAST"/>
    </enumeration>
    <enumeration name="DeviceType" c:type="NMDeviceType">
      <doc xml:whitespace="preserve">#NMDeviceType values indicate the type of hardware represented by
an #NMDevice.</doc>
      <member name="unknown" value="0" c:identifier="NM_DEVICE_TYPE_UNKNOWN"/>
      <member name="ethernet"
              value="1"
              c:identifier="NM_DEVICE_TYPE_ETHERNET"/>
      <member name="wifi" value="2" c:identifier="NM_DEVICE_TYPE_WIFI"/>
      <member name="unused1" value="3" c:identifier="NM_DEVICE_TYPE_UNUSED1"/>
      <member name="unused2" value="4" c:identifier="NM_DEVICE_TYPE_UNUSED2"/>
      <member name="bt" value="5" c:identifier="NM_DEVICE_TYPE_BT"/>
      <member name="olpc_mesh"
              value="6"
              c:identifier="NM_DEVICE_TYPE_OLPC_MESH"/>
      <member name="wimax" value="7" c:identifier="NM_DEVICE_TYPE_WIMAX"/>
      <member name="modem" value="8" c:identifier="NM_DEVICE_TYPE_MODEM"/>
      <member name="infiniband"
              value="9"
              c:identifier="NM_DEVICE_TYPE_INFINIBAND"/>
      <member name="bond" value="10" c:identifier="NM_DEVICE_TYPE_BOND"/>
      <member name="vlan" value="11" c:identifier="NM_DEVICE_TYPE_VLAN"/>
    </enumeration>
    <bitfield name="DeviceWifiCapabilities" c:type="NMDeviceWifiCapabilities">
      <doc xml:whitespace="preserve">802.11 specific device encryption and authentication capabilities.</doc>
      <member name="none" value="0" c:identifier="NM_WIFI_DEVICE_CAP_NONE"/>
      <member name="cipher_wep40"
              value="1"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_WEP40"/>
      <member name="cipher_wep104"
              value="2"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_WEP104"/>
      <member name="cipher_tkip"
              value="4"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_TKIP"/>
      <member name="cipher_ccmp"
              value="8"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_CCMP"/>
      <member name="wpa" value="16" c:identifier="NM_WIFI_DEVICE_CAP_WPA"/>
      <member name="rsn" value="32" c:identifier="NM_WIFI_DEVICE_CAP_RSN"/>
      <member name="ap" value="64" c:identifier="NM_WIFI_DEVICE_CAP_AP"/>
    </bitfield>
    <record name="IP4Address"
            c:type="NMIP4Address"
            glib:type-name="NMIP4Address"
            glib:get-type="nm_ip4_address_get_type"
            c:symbol-prefix="ip4_address">
      <constructor name="new" c:identifier="nm_ip4_address_new">
        <doc xml:whitespace="preserve">Creates and returns a new #NMIP4Address object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMIP4Address object</doc>
          <type name="IP4Address" c:type="NMIP4Address*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip4_address_compare">
        <doc xml:whitespace="preserve">Determines if two #NMIP4Address objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMIP4Address to compare @address to.</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip4_address_dup">
        <doc xml:whitespace="preserve">Copies a given #NMIP4Address object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the copy of the given #NMIP4Address copy</doc>
          <type name="IP4Address" c:type="NMIP4Address*"/>
        </return-value>
      </method>
      <method name="get_address" c:identifier="nm_ip4_address_get_address">
        <doc xml:whitespace="preserve">Gets the IPv4 address property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_gateway" c:identifier="nm_ip4_address_get_gateway">
        <doc xml:whitespace="preserve">Gets the IPv4 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 gateway address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_prefix" c:identifier="nm_ip4_address_get_prefix">
        <doc xml:whitespace="preserve">Gets the IPv4 address prefix (ie "24" or "30" etc) property of this address
object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 address prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="nm_ip4_address_ref">
        <doc xml:whitespace="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_address" c:identifier="nm_ip4_address_set_address">
        <doc xml:whitespace="preserve">Sets the IPv4 address property of this object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv4 address in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gateway" c:identifier="nm_ip4_address_set_gateway">
        <doc xml:whitespace="preserve">Sets the IPv4 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gateway" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv4 default gateway in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip4_address_set_prefix">
        <doc xml:whitespace="preserve">Sets the IPv4 address prefix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address prefix, a number between 1 and 32 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip4_address_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="IP4Route"
            c:type="NMIP4Route"
            glib:type-name="NMIP4Route"
            glib:get-type="nm_ip4_route_get_type"
            c:symbol-prefix="ip4_route">
      <constructor name="new" c:identifier="nm_ip4_route_new">
        <doc xml:whitespace="preserve">Creates and returns a new #NMIP4Route object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMIP4Route object</doc>
          <type name="IP4Route" c:type="NMIP4Route*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip4_route_compare">
        <doc xml:whitespace="preserve">Determines if two #NMIP4Route objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMIP4Route to compare @route to.</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip4_route_dup">
        <doc xml:whitespace="preserve">Copies a given #NMIP4Route object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the copy of the given #NMIP4Route copy</doc>
          <type name="IP4Route" c:type="NMIP4Route*"/>
        </return-value>
      </method>
      <method name="get_dest" c:identifier="nm_ip4_route_get_dest">
        <doc xml:whitespace="preserve">Gets the IPv4 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_metric" c:identifier="nm_ip4_route_get_metric">
        <doc xml:whitespace="preserve">Gets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the route metric</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_next_hop" c:identifier="nm_ip4_route_get_next_hop">
        <doc xml:whitespace="preserve">Gets the IPv4 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_prefix" c:identifier="nm_ip4_route_get_prefix">
        <doc xml:whitespace="preserve">Gets the IPv4 prefix (ie "24" or "30" etc) of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="nm_ip4_route_ref">
        <doc xml:whitespace="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_dest" c:identifier="nm_ip4_route_set_dest">
        <doc xml:whitespace="preserve">Sets the IPv4 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination address in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_metric" c:identifier="nm_ip4_route_set_metric">
        <doc xml:whitespace="preserve">Sets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:whitespace="preserve">the route metric</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_hop" c:identifier="nm_ip4_route_set_next_hop">
        <doc xml:whitespace="preserve">Sets the IPv4 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="next_hop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv4 address of the next hop in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip4_route_set_prefix">
        <doc xml:whitespace="preserve">Sets the IPv4 prefix of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:whitespace="preserve">the prefix, a number between 1 and 32 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip4_route_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="IP6Address"
            c:type="NMIP6Address"
            glib:type-name="NMIP6Address"
            glib:get-type="nm_ip6_address_get_type"
            c:symbol-prefix="ip6_address">
      <constructor name="new" c:identifier="nm_ip6_address_new">
        <doc xml:whitespace="preserve">Creates and returns a new #NMIP6Address object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMIP6Address object</doc>
          <type name="IP6Address" c:type="NMIP6Address*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip6_address_compare">
        <doc xml:whitespace="preserve">Determines if two #NMIP6Address objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMIP6Address to compare @address to.</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip6_address_dup">
        <doc xml:whitespace="preserve">Copies a given #NMIP6Address object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the copy of the given #NMIP6Address copy</doc>
          <type name="IP6Address" c:type="NMIP6Address*"/>
        </return-value>
      </method>
      <method name="get_address" c:identifier="nm_ip6_address_get_address">
        <doc xml:whitespace="preserve">Gets the IPv6 address property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 address</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </return-value>
      </method>
      <method name="get_gateway" c:identifier="nm_ip6_address_get_gateway">
        <doc xml:whitespace="preserve">Gets the IPv6 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 gateway address</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </return-value>
      </method>
      <method name="get_prefix" c:identifier="nm_ip6_address_get_prefix">
        <doc xml:whitespace="preserve">Gets the IPv6 address prefix property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 address prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="nm_ip6_address_ref">
        <doc xml:whitespace="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_address" c:identifier="nm_ip6_address_set_address">
        <doc xml:whitespace="preserve">Sets the IPv6 address property of this object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv6 address</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gateway" c:identifier="nm_ip6_address_set_gateway">
        <doc xml:whitespace="preserve">Sets the IPv6 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gateway" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv6 default gateway</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip6_address_set_prefix">
        <doc xml:whitespace="preserve">Sets the IPv6 address prefix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:whitespace="preserve">the address prefix, a number between 0 and 128 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip6_address_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="IP6Route"
            c:type="NMIP6Route"
            glib:type-name="NMIP6Route"
            glib:get-type="nm_ip6_route_get_type"
            c:symbol-prefix="ip6_route">
      <constructor name="new" c:identifier="nm_ip6_route_new">
        <doc xml:whitespace="preserve">Creates and returns a new #NMIP6Route object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMIP6Route object</doc>
          <type name="IP6Route" c:type="NMIP6Route*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip6_route_compare">
        <doc xml:whitespace="preserve">Determines if two #NMIP6Route objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMIP6Route to compare @route to.</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip6_route_dup">
        <doc xml:whitespace="preserve">Copies a given #NMIP6Route object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the copy of the given #NMIP6Route copy</doc>
          <type name="IP6Route" c:type="NMIP6Route*"/>
        </return-value>
      </method>
      <method name="get_dest" c:identifier="nm_ip6_route_get_dest">
        <doc xml:whitespace="preserve">Gets the IPv6 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 address</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </return-value>
      </method>
      <method name="get_metric" c:identifier="nm_ip6_route_get_metric">
        <doc xml:whitespace="preserve">Gets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the route metric</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_next_hop" c:identifier="nm_ip6_route_get_next_hop">
        <doc xml:whitespace="preserve">Gets the IPv6 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 address</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </return-value>
      </method>
      <method name="get_prefix" c:identifier="nm_ip6_route_get_prefix">
        <doc xml:whitespace="preserve">Gets the IPv6 prefix (ie "32" or "64" etc) of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="nm_ip6_route_ref">
        <doc xml:whitespace="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_dest" c:identifier="nm_ip6_route_set_dest">
        <doc xml:whitespace="preserve">Sets the IPv6 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination address</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_metric" c:identifier="nm_ip6_route_set_metric">
        <doc xml:whitespace="preserve">Sets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:whitespace="preserve">the route metric</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_hop" c:identifier="nm_ip6_route_set_next_hop">
        <doc xml:whitespace="preserve">Sets the IPv6 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="next_hop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv6 address of the next hop</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip6_route_set_prefix">
        <doc xml:whitespace="preserve">Sets the IPv6 prefix of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:whitespace="preserve">the prefix, a number between 1 and 128 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip6_route_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <constant name="SETTING_802_1X_ALTSUBJECT_MATCHES"
              value="altsubject-matches"
              c:type="NM_SETTING_802_1X_ALTSUBJECT_MATCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_ANONYMOUS_IDENTITY"
              value="anonymous-identity"
              c:type="NM_SETTING_802_1X_ANONYMOUS_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_CERT"
              value="ca-cert"
              c:type="NM_SETTING_802_1X_CA_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_PATH"
              value="ca-path"
              c:type="NM_SETTING_802_1X_CA_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CLIENT_CERT"
              value="client-cert"
              c:type="NM_SETTING_802_1X_CLIENT_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_EAP"
              value="eap"
              c:type="NM_SETTING_802_1X_EAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_IDENTITY"
              value="identity"
              c:type="NM_SETTING_802_1X_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PAC_FILE"
              value="pac-file"
              c:type="NM_SETTING_802_1X_PAC_FILE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD"
              value="password"
              c:type="NM_SETTING_802_1X_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_802_1X_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_RAW"
              value="password-raw"
              c:type="NM_SETTING_802_1X_PASSWORD_RAW">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_RAW_FLAGS"
              value="password-raw-flags"
              c:type="NM_SETTING_802_1X_PASSWORD_RAW_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_FAST_PROVISIONING"
              value="phase1-fast-provisioning"
              c:type="NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_PEAPLABEL"
              value="phase1-peaplabel"
              c:type="NM_SETTING_802_1X_PHASE1_PEAPLABEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_PEAPVER"
              value="phase1-peapver"
              c:type="NM_SETTING_802_1X_PHASE1_PEAPVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES"
              value="phase2-altsubject-matches"
              c:type="NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_AUTH"
              value="phase2-auth"
              c:type="NM_SETTING_802_1X_PHASE2_AUTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_AUTHEAP"
              value="phase2-autheap"
              c:type="NM_SETTING_802_1X_PHASE2_AUTHEAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_CERT"
              value="phase2-ca-cert"
              c:type="NM_SETTING_802_1X_PHASE2_CA_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_PATH"
              value="phase2-ca-path"
              c:type="NM_SETTING_802_1X_PHASE2_CA_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CLIENT_CERT"
              value="phase2-client-cert"
              c:type="NM_SETTING_802_1X_PHASE2_CLIENT_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY"
              value="phase2-private-key"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD"
              value="phase2-private-key-password"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS"
              value="phase2-private-key-password-flags"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_SUBJECT_MATCH"
              value="phase2-subject-match"
              c:type="NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PIN"
              value="pin"
              c:type="NM_SETTING_802_1X_PIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PIN_FLAGS"
              value="pin-flags"
              c:type="NM_SETTING_802_1X_PIN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY"
              value="private-key"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY_PASSWORD"
              value="private-key-password"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS"
              value="private-key-password-flags"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SETTING_NAME"
              value="802-1x"
              c:type="NM_SETTING_802_1X_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SUBJECT_MATCH"
              value="subject-match"
              c:type="NM_SETTING_802_1X_SUBJECT_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SYSTEM_CA_CERTS"
              value="system-ca-certs"
              c:type="NM_SETTING_802_1X_SYSTEM_CA_CERTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_BDADDR"
              value="bdaddr"
              c:type="NM_SETTING_BLUETOOTH_BDADDR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_SETTING_NAME"
              value="bluetooth"
              c:type="NM_SETTING_BLUETOOTH_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE"
              value="type"
              c:type="NM_SETTING_BLUETOOTH_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE_DUN"
              value="dun"
              c:type="NM_SETTING_BLUETOOTH_TYPE_DUN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE_PANU"
              value="panu"
              c:type="NM_SETTING_BLUETOOTH_TYPE_PANU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_BOND_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTIONS"
              value="options"
              c:type="NM_SETTING_BOND_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_INTERVAL"
              value="arp_interval"
              c:type="NM_SETTING_BOND_OPTION_ARP_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_IP_TARGET"
              value="arp_ip_target"
              c:type="NM_SETTING_BOND_OPTION_ARP_IP_TARGET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_DOWNDELAY"
              value="downdelay"
              c:type="NM_SETTING_BOND_OPTION_DOWNDELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MIIMON"
              value="miimon"
              c:type="NM_SETTING_BOND_OPTION_MIIMON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MODE"
              value="mode"
              c:type="NM_SETTING_BOND_OPTION_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_UPDELAY"
              value="updelay"
              c:type="NM_SETTING_BOND_OPTION_UPDELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_SETTING_NAME"
              value="bond"
              c:type="NM_SETTING_BOND_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_NUMBER"
              value="number"
              c:type="NM_SETTING_CDMA_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_PASSWORD"
              value="password"
              c:type="NM_SETTING_CDMA_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_CDMA_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_SETTING_NAME"
              value="cdma"
              c:type="NM_SETTING_CDMA_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_USERNAME"
              value="username"
              c:type="NM_SETTING_CDMA_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT"
              value="autoconnect"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ID"
              value="id"
              c:type="NM_SETTING_CONNECTION_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_MASTER"
              value="master"
              c:type="NM_SETTING_CONNECTION_MASTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_PERMISSIONS"
              value="permissions"
              c:type="NM_SETTING_CONNECTION_PERMISSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_READ_ONLY"
              value="read-only"
              c:type="NM_SETTING_CONNECTION_READ_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SETTING_NAME"
              value="connection"
              c:type="NM_SETTING_CONNECTION_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SLAVE_TYPE"
              value="slave-type"
              c:type="NM_SETTING_CONNECTION_SLAVE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_TIMESTAMP"
              value="timestamp"
              c:type="NM_SETTING_CONNECTION_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_TYPE"
              value="type"
              c:type="NM_SETTING_CONNECTION_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_UUID"
              value="uuid"
              c:type="NM_SETTING_CONNECTION_UUID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE"
              value="zone"
              c:type="NM_SETTING_CONNECTION_ZONE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE_BLOCK"
              value="block"
              c:type="NM_SETTING_CONNECTION_ZONE_BLOCK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE_HOME"
              value="home"
              c:type="NM_SETTING_CONNECTION_ZONE_HOME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE_PUBLIC"
              value="public"
              c:type="NM_SETTING_CONNECTION_ZONE_PUBLIC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE_TRUSTED"
              value="trusted"
              c:type="NM_SETTING_CONNECTION_ZONE_TRUSTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE_WORK"
              value="work"
              c:type="NM_SETTING_CONNECTION_ZONE_WORK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_ALLOWED_BANDS"
              value="allowed-bands"
              c:type="NM_SETTING_GSM_ALLOWED_BANDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_APN" value="apn" c:type="NM_SETTING_GSM_APN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_HOME_ONLY"
              value="home-only"
              c:type="NM_SETTING_GSM_HOME_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NETWORK_ID"
              value="network-id"
              c:type="NM_SETTING_GSM_NETWORK_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NETWORK_TYPE"
              value="network-type"
              c:type="NM_SETTING_GSM_NETWORK_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NUMBER"
              value="number"
              c:type="NM_SETTING_GSM_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PASSWORD"
              value="password"
              c:type="NM_SETTING_GSM_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_GSM_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PIN" value="pin" c:type="NM_SETTING_GSM_PIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PIN_FLAGS"
              value="pin-flags"
              c:type="NM_SETTING_GSM_PIN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_SETTING_NAME"
              value="gsm"
              c:type="NM_SETTING_GSM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_USERNAME"
              value="username"
              c:type="NM_SETTING_GSM_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_INFINIBAND_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_MTU"
              value="mtu"
              c:type="NM_SETTING_INFINIBAND_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_SETTING_NAME"
              value="infiniband"
              c:type="NM_SETTING_INFINIBAND_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_TRANSPORT_MODE"
              value="transport-mode"
              c:type="NM_SETTING_INFINIBAND_TRANSPORT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_SETTING_IP4_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_CLIENT_ID"
              value="dhcp-client-id"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_HOSTNAME"
              value="dhcp-hostname"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_SEND_HOSTNAME"
              value="dhcp-send-hostname"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_SEND_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DNS"
              value="dns"
              c:type="NM_SETTING_IP4_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DNS_SEARCH"
              value="dns-search"
              c:type="NM_SETTING_IP4_CONFIG_DNS_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_IGNORE_AUTO_DNS"
              value="ignore-auto-dns"
              c:type="NM_SETTING_IP4_CONFIG_IGNORE_AUTO_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_IGNORE_AUTO_ROUTES"
              value="ignore-auto-routes"
              c:type="NM_SETTING_IP4_CONFIG_IGNORE_AUTO_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_MAY_FAIL"
              value="may-fail"
              c:type="NM_SETTING_IP4_CONFIG_MAY_FAIL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD"
              value="method"
              c:type="NM_SETTING_IP4_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_AUTO"
              value="auto"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_AUTO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_DISABLED"
              value="disabled"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_DISABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_LINK_LOCAL"
              value="link-local"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_MANUAL"
              value="manual"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_MANUAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_SHARED"
              value="shared"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_SHARED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_SETTING_IP4_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_SETTING_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_SETTING_NAME"
              value="ipv4"
              c:type="NM_SETTING_IP4_CONFIG_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_SETTING_IP6_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_DNS"
              value="dns"
              c:type="NM_SETTING_IP6_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_DNS_SEARCH"
              value="dns-search"
              c:type="NM_SETTING_IP6_CONFIG_DNS_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IGNORE_AUTO_DNS"
              value="ignore-auto-dns"
              c:type="NM_SETTING_IP6_CONFIG_IGNORE_AUTO_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IGNORE_AUTO_ROUTES"
              value="ignore-auto-routes"
              c:type="NM_SETTING_IP6_CONFIG_IGNORE_AUTO_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IP6_PRIVACY"
              value="ip6-privacy"
              c:type="NM_SETTING_IP6_CONFIG_IP6_PRIVACY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_MAY_FAIL"
              value="may-fail"
              c:type="NM_SETTING_IP6_CONFIG_MAY_FAIL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD"
              value="method"
              c:type="NM_SETTING_IP6_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_AUTO"
              value="auto"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_AUTO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_DHCP"
              value="dhcp"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_DHCP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_IGNORE"
              value="ignore"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_IGNORE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_LINK_LOCAL"
              value="link-local"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_MANUAL"
              value="manual"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_MANUAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_SHARED"
              value="shared"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_SHARED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_SETTING_IP6_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_ROUTES"
              value="routes"
              c:type="NM_SETTING_IP6_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_SETTING_NAME"
              value="ipv6"
              c:type="NM_SETTING_IP6_CONFIG_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_NAME" value="name" c:type="NM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_CHANNEL"
              value="channel"
              c:type="NM_SETTING_OLPC_MESH_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS"
              value="dhcp-anycast-address"
              c:type="NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_SETTING_NAME"
              value="802-11-olpc-mesh"
              c:type="NM_SETTING_OLPC_MESH_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_SSID"
              value="ssid"
              c:type="NM_SETTING_OLPC_MESH_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PARAM_FUZZY_IGNORE"
              value="8"
              c:type="NM_SETTING_PARAM_FUZZY_IGNORE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_REQUIRED"
              value="2"
              c:type="NM_SETTING_PARAM_REQUIRED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_SECRET"
              value="4"
              c:type="NM_SETTING_PARAM_SECRET">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_SERIALIZE"
              value="1"
              c:type="NM_SETTING_PARAM_SERIALIZE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PPPOE_PASSWORD"
              value="password"
              c:type="NM_SETTING_PPPOE_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_PPPOE_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_SERVICE"
              value="service"
              c:type="NM_SETTING_PPPOE_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_SETTING_NAME"
              value="pppoe"
              c:type="NM_SETTING_PPPOE_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_USERNAME"
              value="username"
              c:type="NM_SETTING_PPPOE_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_BAUD"
              value="baud"
              c:type="NM_SETTING_PPP_BAUD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_CRTSCTS"
              value="crtscts"
              c:type="NM_SETTING_PPP_CRTSCTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_LCP_ECHO_FAILURE"
              value="lcp-echo-failure"
              c:type="NM_SETTING_PPP_LCP_ECHO_FAILURE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_LCP_ECHO_INTERVAL"
              value="lcp-echo-interval"
              c:type="NM_SETTING_PPP_LCP_ECHO_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MPPE_STATEFUL"
              value="mppe-stateful"
              c:type="NM_SETTING_PPP_MPPE_STATEFUL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MRU" value="mru" c:type="NM_SETTING_PPP_MRU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MTU" value="mtu" c:type="NM_SETTING_PPP_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NOAUTH"
              value="noauth"
              c:type="NM_SETTING_PPP_NOAUTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NOBSDCOMP"
              value="nobsdcomp"
              c:type="NM_SETTING_PPP_NOBSDCOMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NODEFLATE"
              value="nodeflate"
              c:type="NM_SETTING_PPP_NODEFLATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NO_VJ_COMP"
              value="no-vj-comp"
              c:type="NM_SETTING_PPP_NO_VJ_COMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_CHAP"
              value="refuse-chap"
              c:type="NM_SETTING_PPP_REFUSE_CHAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_EAP"
              value="refuse-eap"
              c:type="NM_SETTING_PPP_REFUSE_EAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_MSCHAP"
              value="refuse-mschap"
              c:type="NM_SETTING_PPP_REFUSE_MSCHAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_MSCHAPV2"
              value="refuse-mschapv2"
              c:type="NM_SETTING_PPP_REFUSE_MSCHAPV2">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_PAP"
              value="refuse-pap"
              c:type="NM_SETTING_PPP_REFUSE_PAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REQUIRE_MPPE"
              value="require-mppe"
              c:type="NM_SETTING_PPP_REQUIRE_MPPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REQUIRE_MPPE_128"
              value="require-mppe-128"
              c:type="NM_SETTING_PPP_REQUIRE_MPPE_128">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_SETTING_NAME"
              value="ppp"
              c:type="NM_SETTING_PPP_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_BAUD"
              value="baud"
              c:type="NM_SETTING_SERIAL_BAUD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_BITS"
              value="bits"
              c:type="NM_SETTING_SERIAL_BITS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_PARITY"
              value="parity"
              c:type="NM_SETTING_SERIAL_PARITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_SEND_DELAY"
              value="send-delay"
              c:type="NM_SETTING_SERIAL_SEND_DELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_SETTING_NAME"
              value="serial"
              c:type="NM_SETTING_SERIAL_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_STOPBITS"
              value="stopbits"
              c:type="NM_SETTING_SERIAL_STOPBITS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_EGRESS_PRIORITY_MAP"
              value="egress-priority-map"
              c:type="NM_SETTING_VLAN_EGRESS_PRIORITY_MAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_FLAGS"
              value="flags"
              c:type="NM_SETTING_VLAN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_ID" value="id" c:type="NM_SETTING_VLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_INGRESS_PRIORITY_MAP"
              value="ingress-priority-map"
              c:type="NM_SETTING_VLAN_INGRESS_PRIORITY_MAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_VLAN_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_PARENT"
              value="parent"
              c:type="NM_SETTING_VLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_SETTING_NAME"
              value="vlan"
              c:type="NM_SETTING_VLAN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_DATA"
              value="data"
              c:type="NM_SETTING_VPN_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SECRETS"
              value="secrets"
              c:type="NM_SETTING_VPN_SECRETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SERVICE_TYPE"
              value="service-type"
              c:type="NM_SETTING_VPN_SERVICE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SETTING_NAME"
              value="vpn"
              c:type="NM_SETTING_VPN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_USER_NAME"
              value="user-name"
              c:type="NM_SETTING_VPN_USER_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIMAX_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_NETWORK_NAME"
              value="network-name"
              c:type="NM_SETTING_WIMAX_NETWORK_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_SETTING_NAME"
              value="wimax"
              c:type="NM_SETTING_WIMAX_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_AUTO_NEGOTIATE"
              value="auto-negotiate"
              c:type="NM_SETTING_WIRED_AUTO_NEGOTIATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_CLONED_MAC_ADDRESS"
              value="cloned-mac-address"
              c:type="NM_SETTING_WIRED_CLONED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_DUPLEX"
              value="duplex"
              c:type="NM_SETTING_WIRED_DUPLEX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIRED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MAC_ADDRESS_BLACKLIST"
              value="mac-address-blacklist"
              c:type="NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MTU"
              value="mtu"
              c:type="NM_SETTING_WIRED_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_PORT"
              value="port"
              c:type="NM_SETTING_WIRED_PORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_NETTYPE"
              value="s390-nettype"
              c:type="NM_SETTING_WIRED_S390_NETTYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_OPTIONS"
              value="s390-options"
              c:type="NM_SETTING_WIRED_S390_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_SUBCHANNELS"
              value="s390-subchannels"
              c:type="NM_SETTING_WIRED_S390_SUBCHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_SETTING_NAME"
              value="802-3-ethernet"
              c:type="NM_SETTING_WIRED_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_SPEED"
              value="speed"
              c:type="NM_SETTING_WIRED_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_BAND"
              value="band"
              c:type="NM_SETTING_WIRELESS_BAND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_BSSID"
              value="bssid"
              c:type="NM_SETTING_WIRELESS_BSSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_CHANNEL"
              value="channel"
              c:type="NM_SETTING_WIRELESS_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_CLONED_MAC_ADDRESS"
              value="cloned-mac-address"
              c:type="NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST"
              value="mac-address-blacklist"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE"
              value="mode"
              c:type="NM_SETTING_WIRELESS_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_ADHOC"
              value="adhoc"
              c:type="NM_SETTING_WIRELESS_MODE_ADHOC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_INFRA"
              value="infrastructure"
              c:type="NM_SETTING_WIRELESS_MODE_INFRA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MTU"
              value="mtu"
              c:type="NM_SETTING_WIRELESS_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_RATE"
              value="rate"
              c:type="NM_SETTING_WIRELESS_RATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SEC"
              value="security"
              c:type="NM_SETTING_WIRELESS_SEC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_AUTH_ALG"
              value="auth-alg"
              c:type="NM_SETTING_WIRELESS_SECURITY_AUTH_ALG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_GROUP"
              value="group"
              c:type="NM_SETTING_WIRELESS_SECURITY_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_KEY_MGMT"
              value="key-mgmt"
              c:type="NM_SETTING_WIRELESS_SECURITY_KEY_MGMT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_PASSWORD"
              value="leap-password"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS"
              value="leap-password-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_USERNAME"
              value="leap-username"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PAIRWISE"
              value="pairwise"
              c:type="NM_SETTING_WIRELESS_SECURITY_PAIRWISE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PROTO"
              value="proto"
              c:type="NM_SETTING_WIRELESS_SECURITY_PROTO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PSK"
              value="psk"
              c:type="NM_SETTING_WIRELESS_SECURITY_PSK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PSK_FLAGS"
              value="psk-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_SETTING_NAME"
              value="802-11-wireless-security"
              c:type="NM_SETTING_WIRELESS_SECURITY_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY0"
              value="wep-key0"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY0">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY1"
              value="wep-key1"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY1">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY2"
              value="wep-key2"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY2">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY3"
              value="wep-key3"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY3">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS"
              value="wep-key-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE"
              value="wep-key-type"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX"
              value="wep-tx-keyidx"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SEEN_BSSIDS"
              value="seen-bssids"
              c:type="NM_SETTING_WIRELESS_SEEN_BSSIDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SETTING_NAME"
              value="802-11-wireless"
              c:type="NM_SETTING_WIRELESS_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SSID"
              value="ssid"
              c:type="NM_SETTING_WIRELESS_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_TX_POWER"
              value="tx-power"
              c:type="NM_SETTING_WIRELESS_TX_POWER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Setting"
           c:symbol-prefix="setting"
           c:type="NMSetting"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMSetting"
           glib:get-type="nm_setting_get_type"
           glib:type-struct="SettingClass">
      <doc xml:whitespace="preserve">The NMSetting struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <constructor name="new_from_hash"
                   c:identifier="nm_setting_new_from_hash">
        <doc xml:whitespace="preserve">Creates a new #NMSetting object and populates that object with the properties
contained in the hash table, using each hash key as the property to set,
and each hash value as the value to set that property to.  Setting properties
are strongly typed, thus the GValue type of the hash value must be correct.
See the documentation on each #NMSetting object subclass for the correct
property names and value types.

hash table, or NULL on failure</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #NMSetting object populated with the properties from the</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMSetting type which the hash contains properties for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GHashTable containing a string to GValue mapping of properties that apply to the setting</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="clear_secrets_with_flags" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2">
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="compare_property">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="prop_spec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_secret_flags" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="secret_name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="verify_secret" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="out_flags" transfer-ownership="none">
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_virtual_iface_name"
                      invoker="get_virtual_iface_name">
        <doc xml:whitespace="preserve">Returns the name of the virtual kernel interface which the connection
needs to use if specified in the settings.

support this feature</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the virtual interface or %NULL if the setting does not</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="need_secrets" invoker="need_secrets">
        <doc xml:whitespace="preserve">Returns an array of property names for each secret which may be required
to make a successful connection.  The returned hints are only intended as a
guide to what secrets may be required, because in some circumstances, there
is no way to conclusively determine exactly which secrets are needed.

#NMSetting which may be required; the caller owns the array
and must free the each array element with g_free(), as well as the array
itself with g_ptr_array_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GPtrArray containing the property names of secrets of the</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="set_secret_flags" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="secret_name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="verify_secret" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_one_secret" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify" invoker="verify" throws="1">
        <doc xml:whitespace="preserve">Validates the setting.  Each setting's properties have allowed values, and
some are dependent on other values (hence the need for @all_settings).  The
returned #GError contains information about which property of the setting
failed validation, and in what way that property failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the setting is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="all_settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSList of all settings in the connection from which @setting came</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="Setting"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear_secrets" c:identifier="nm_setting_clear_secrets">
        <doc xml:whitespace="preserve">Resets and clears any secrets in the setting.  Secrets should be added to the
setting only when needed, and cleared immediately after use to prevent
leakage of information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_secrets_with_flags"
              c:identifier="nm_setting_clear_secrets_with_flags">
        <doc xml:whitespace="preserve">Clears and frees secrets determined by @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">function to be called to determine whether a specific secret should be cleared or not</doc>
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-supplied data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="nm_setting_compare">
        <doc xml:whitespace="preserve">Compares two #NMSetting objects for similarity, with comparison behavior
modified by a set of flags.  See the documentation for #NMSettingCompareFlags
for a description of each flag's behavior.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the comparison succeeds, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">a second #NMSetting to compare with the first</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="diff" c:identifier="nm_setting_diff">
        <doc xml:whitespace="preserve">Compares two #NMSetting objects for similarity, with comparison behavior
modified by a set of flags.  See the documentation for #NMSettingCompareFlags
for a description of each flag's behavior.  If the settings differ, the keys
of each setting that differ from the other are added to @results, mapped to
one or more #NMSettingDiffResult values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the settings contain the same values, %FALSE if they do not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">a second #NMSetting to compare with the first</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
          <parameter name="invert_results" transfer-ownership="none">
            <doc xml:whitespace="preserve">this parameter is used internally by libnm-util and should be set to %FALSE.  If %TRUE inverts the meaning of the #NMSettingDiffResult.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="results"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if the settings differ, on return a hash table mapping the differing keys to one or more %NMSettingDiffResult values OR-ed together.  If the settings do not differ, any hash table passed in is unmodified.  If no hash table is passed in and the settings differ, a new one is created and returned.</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="guint32"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="duplicate" c:identifier="nm_setting_duplicate">
        <doc xml:whitespace="preserve">Duplicates a #NMSetting.

source #NMSetting</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #NMSetting containing the same properties and values as the</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </method>
      <method name="enumerate_values"
              c:identifier="nm_setting_enumerate_values">
        <doc xml:whitespace="preserve">Iterates over each property of the #NMSetting object, calling the supplied
user function for each property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">user-supplied function called for each property of the setting</doc>
            <type name="SettingValueIterFn" c:type="NMSettingValueIterFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func at each invocation</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_setting_get_name">
        <doc xml:whitespace="preserve">Returns the type name of the #NMSetting object

like 'ppp' or 'wireless' or 'wired'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string containing the type name of the #NMSetting object,</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_secret_flags"
              c:identifier="nm_setting_get_secret_flags"
              throws="1">
        <doc xml:whitespace="preserve">For a given secret, retrieves the #NMSettingSecretFlags describing how to
handle that secret.

this setting, and if that property is secret), FALSE if not</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success (if the given secret name was a valid property of</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the secret key name to get flags for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">on success, the #NMSettingSecretFlags for the secret</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_virtual_iface_name"
              c:identifier="nm_setting_get_virtual_iface_name">
        <doc xml:whitespace="preserve">Returns the name of the virtual kernel interface which the connection
needs to use if specified in the settings.

support this feature</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the virtual interface or %NULL if the setting does not</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="need_secrets" c:identifier="nm_setting_need_secrets">
        <doc xml:whitespace="preserve">Returns an array of property names for each secret which may be required
to make a successful connection.  The returned hints are only intended as a
guide to what secrets may be required, because in some circumstances, there
is no way to conclusively determine exactly which secrets are needed.

#NMSetting which may be required; the caller owns the array
and must free the each array element with g_free(), as well as the array
itself with g_ptr_array_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GPtrArray containing the property names of secrets of the</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="set_secret_flags"
              c:identifier="nm_setting_set_secret_flags"
              throws="1">
        <doc xml:whitespace="preserve">For a given secret, retrieves the #NMSettingSecretFlags describing how to
handle that secret.

this setting, and if that property is secret), FALSE if not</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success (if the given secret name was a valid property of</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the secret key name to set flags for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMSettingSecretFlags for the secret</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hash" c:identifier="nm_setting_to_hash">
        <doc xml:whitespace="preserve">Converts the #NMSetting into a #GHashTable mapping each setting property
name to a GValue describing that property, suitable for marshalling over
D-Bus or serializing.  The mapping is string to GValue.

describing the setting's properties</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">hash flags, e.g. %NM_SETTING_HASH_FLAG_ALL</doc>
            <type name="SettingHashFlags" c:type="NMSettingHashFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="nm_setting_to_string">
        <doc xml:whitespace="preserve">Convert the setting into a string.  For debugging purposes ONLY, should NOT
be used for serialization of the setting, or machine-parsed in any way. The
output format is not guaranteed to be stable and may change at any time.

setting's properties and values (including secrets!), which the caller should
free with g_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an allocated string containing a textual representation of the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="update_secrets"
              c:identifier="nm_setting_update_secrets"
              throws="1">
        <doc xml:whitespace="preserve">Update the setting's secrets, given a hash table of secrets intended for that
setting (deserialized from D-Bus for example).

is valid, %FALSE on failure or if the setting was never added to the connection</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the secrets were successfully updated and the connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="secrets" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable mapping string to #GValue of setting property names and secrets</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="nm_setting_verify" throws="1">
        <doc xml:whitespace="preserve">Validates the setting.  Each setting's properties have allowed values, and
some are dependent on other values (hence the need for @all_settings).  The
returned #GError contains information about which property of the setting
failed validation, and in what way that property failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the setting is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="all_settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GSList of all settings in the connection from which @setting came</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="Setting"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="name" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The setting's name, which uniquely identifies the setting within the
connection.  Each setting type has a name unique to that type, for
example 'ppp' or 'wireless' or 'wired'.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="Setting8021x"
           c:symbol-prefix="setting_802_1x"
           c:type="NMSetting8021x"
           parent="Setting"
           glib:type-name="NMSetting8021x"
           glib:get-type="nm_setting_802_1x_get_type"
           glib:type-struct="Setting8021xClass">
      <constructor name="new" c:identifier="nm_setting_802_1x_new">
        <doc xml:whitespace="preserve">Creates a new #NMSetting8021x object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSetting8021x object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_altsubject_match"
              c:identifier="nm_setting_802_1x_add_altsubject_match">
        <doc xml:whitespace="preserve">Adds an allowed alternate subject name match.  Until at least one
match is added, the altSubjectName of the remote authentication
server is not verified.

successfully added, FALSE if it was already allowed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the alternative subject name match was</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="altsubject_match" transfer-ownership="none">
            <doc xml:whitespace="preserve">the altSubjectName to allow for this connection</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_eap_method"
              c:identifier="nm_setting_802_1x_add_eap_method">
        <doc xml:whitespace="preserve">Adds an allowed EAP method.  The setting is not valid until at least one
EAP method has been added.  See #NMSetting8021x:eap property for a list of
allowed EAP methods.

not a valid method or if it was already allowed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the EAP method was successfully added, FALSE if it was</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="eap" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the EAP method to allow for this connection</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_add_phase2_altsubject_match">
        <doc xml:whitespace="preserve">Adds an allowed alternate subject name match for "phase 2".  Until
at least one match is added, the altSubjectName of the "phase 2"
remote authentication server is not verified.

successfully added, FALSE if it was already allowed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the "phase 2" alternative subject name match was</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="phase2_altsubject_match" transfer-ownership="none">
            <doc xml:whitespace="preserve">the "phase 2" altSubjectName to allow for this connection</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_altsubject_matches"
              c:identifier="nm_setting_802_1x_clear_altsubject_matches">
        <doc xml:whitespace="preserve">Clears all altSubjectName matches.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_eap_methods"
              c:identifier="nm_setting_802_1x_clear_eap_methods">
        <doc xml:whitespace="preserve">Clears all allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_phase2_altsubject_matches"
              c:identifier="nm_setting_802_1x_clear_phase2_altsubject_matches">
        <doc xml:whitespace="preserve">Clears all "phase 2" altSubjectName matches.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_altsubject_match"
              c:identifier="nm_setting_802_1x_get_altsubject_match">
        <doc xml:whitespace="preserve">Returns the altSubjectName match at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the altSubjectName match at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the zero-based index of the array of altSubjectName matches</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_anonymous_identity"
              c:identifier="nm_setting_802_1x_get_anonymous_identity">
        <doc xml:whitespace="preserve">Returns the anonymous identifier used by some EAP methods (like TTLS) to
authenticate the user in the outer unencrypted "phase 1" authentication.  The
inner "phase 2" authentication will use the #NMSetting8021x:identity in
a secure form, if applicable for that EAP method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the anonymous identifier</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_ca_cert_blob"
              c:identifier="nm_setting_802_1x_get_ca_cert_blob">
        <doc xml:whitespace="preserve">Returns the CA certificate blob if the CA certificate is stored using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use a
CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the CA certificate data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_ca_cert_path"
              c:identifier="nm_setting_802_1x_get_ca_cert_path">
        <doc xml:whitespace="preserve">Returns the CA certificate path if the CA certificate is stored using the
%NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use a
CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">path to the CA certificate file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_ca_cert_scheme"
              c:identifier="nm_setting_802_1x_get_ca_cert_scheme">
        <doc xml:whitespace="preserve">Returns the scheme used to store the CA certificate.  If the returned scheme
is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_ca_cert_blob();
if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_ca_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scheme used to store the CA certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
      </method>
      <method name="get_ca_path" c:identifier="nm_setting_802_1x_get_ca_path">
        <doc xml:whitespace="preserve">Returns the path of the CA certificate directory if previously set.  Systems
will often have a directory that contains multiple individual CA certificates
which the supplicant can then add to the verification chain.  This may be
used in addition to the #NMSetting8021x:ca-cert property to add more CA
certificates for verifying the network to client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the CA certificate directory path</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_client_cert_blob"
              c:identifier="nm_setting_802_1x_get_client_cert_blob">
        <doc xml:whitespace="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the client certificate data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_client_cert_path"
              c:identifier="nm_setting_802_1x_get_client_cert_path">
        <doc xml:whitespace="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">path to the client certificate file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_client_cert_scheme"
              c:identifier="nm_setting_802_1x_get_client_cert_scheme">
        <doc xml:whitespace="preserve">Returns the scheme used to store the client certificate.  If the returned scheme
is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_client_cert_blob();
if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scheme used to store the client certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
      </method>
      <method name="get_eap_method"
              c:identifier="nm_setting_802_1x_get_eap_method">
        <doc xml:whitespace="preserve">Returns the name of the allowed EAP method at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the allowed EAP method at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the EAP method name to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identity"
              c:identifier="nm_setting_802_1x_get_identity">
        <doc xml:whitespace="preserve">Returns the identifier used by some EAP methods (like TLS) to
authenticate the user.  Often this is a username or login name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the user identifier</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_num_altsubject_matches"
              c:identifier="nm_setting_802_1x_get_num_altsubject_matches">
        <doc xml:whitespace="preserve">Returns the number of entries in the
#NMSetting8021x:altsubject-matches property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of altsubject-matches entries.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_eap_methods"
              c:identifier="nm_setting_802_1x_get_num_eap_methods">
        <doc xml:whitespace="preserve">Returns the number of eap methods allowed for use when connecting to the
network.  Generally only one EAP method is used.  Use the functions
nm_setting_802_1x_get_eap_method(), nm_setting_802_1x_add_eap_method(),
and nm_setting_802_1x_remove_eap_method() for adding, removing, and retrieving
allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of allowed EAP methods</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_phase2_altsubject_matches"
              c:identifier="nm_setting_802_1x_get_num_phase2_altsubject_matches">
        <doc xml:whitespace="preserve">Returns the number of entries in the
#NMSetting8021x:phase2-altsubject-matches property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of phase2-altsubject-matches entries.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_pac_file"
              c:identifier="nm_setting_802_1x_get_pac_file">
        <doc xml:whitespace="preserve">Returns the file containing PAC credentials used by EAP-FAST method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the PAC file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password"
              c:identifier="nm_setting_802_1x_get_password">
        <doc xml:whitespace="preserve">by the #NMSetting8021x:password property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the password used by the authentication method, if any, as specified</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_802_1x_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the #NMSetting8021x:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_password_raw"
              c:identifier="nm_setting_802_1x_get_password_raw">
        <doc xml:whitespace="preserve">UTF-8-encoded array of bytes, as specified by the
#NMSetting8021x:password-raw property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the password used by the authentication method as a</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_password_raw_flags"
              c:identifier="nm_setting_802_1x_get_password_raw_flags">
        <doc xml:whitespace="preserve">#NMSetting8021x:password-raw</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_phase1_fast_provisioning"
              c:identifier="nm_setting_802_1x_get_phase1_fast_provisioning">
        <doc xml:whitespace="preserve">by the #NMSetting8021x:phase1-fast-provisioning property.  See the
wpa_supplicant documentation for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether "phase 1" PEAP fast provisioning should be used, as specified</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase1_peaplabel"
              c:identifier="nm_setting_802_1x_get_phase1_peaplabel">
        <doc xml:whitespace="preserve">used when authenticating with EAP-PEAP, as contained in the
#NMSetting8021x:phase1-peaplabel property.  Valid values are NULL (unset),
"0" (use old-style label), and "1" (use new-style label).  See the
wpa_supplicant documentation for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the "phase 1" PEAP label is new-style or old-style, to be</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase1_peapver"
              c:identifier="nm_setting_802_1x_get_phase1_peapver">
        <doc xml:whitespace="preserve">EAP-PEAP as contained in the #NMSetting8021x:phase1-peapver property.  Valid
values are NULL (unset), "0" (PEAP version 0), and "1" (PEAP version 1).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 1" PEAP version to be used when authenticating with</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_get_phase2_altsubject_match">
        <doc xml:whitespace="preserve">Returns the "phase 2" altSubjectName match at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" altSubjectName match at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the zero-based index of the array of "phase 2" altSubjectName matches</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_phase2_auth"
              c:identifier="nm_setting_802_1x_get_phase2_auth">
        <doc xml:whitespace="preserve">specified by the #NMSetting8021x:phase2-auth property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" non-EAP (ex MD5) allowed authentication method as</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_autheap"
              c:identifier="nm_setting_802_1x_get_phase2_autheap">
        <doc xml:whitespace="preserve">specified by the #NMSetting8021x:phase2-autheap property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" EAP-based (ex TLS) allowed authentication method as</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_ca_cert_blob"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_blob">
        <doc xml:whitespace="preserve">Returns the "phase 2" CA certificate blob if the CA certificate is stored
using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use
a CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" CA certificate data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_phase2_ca_cert_path"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_path">
        <doc xml:whitespace="preserve">Returns the "phase 2" CA certificate path if the CA certificate is stored
using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use
a CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">path to the "phase 2" CA certificate file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_ca_cert_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_scheme">
        <doc xml:whitespace="preserve">Returns the scheme used to store the "phase 2" CA certificate.  If the
returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_ca_cert_blob(); if %NM_SETTING_802_1X_CK_SCHEME_PATH,
use nm_setting_802_1x_get_ca_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scheme used to store the "phase 2" CA certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
      </method>
      <method name="get_phase2_ca_path"
              c:identifier="nm_setting_802_1x_get_phase2_ca_path">
        <doc xml:whitespace="preserve">Returns the path of the "phase 2" CA certificate directory if previously set.
Systems will often have a directory that contains multiple individual CA
certificates which the supplicant can then add to the verification chain.
This may be used in addition to the #NMSetting8021x:phase2-ca-cert property
to add more CA certificates for verifying the network to client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" CA certificate directory path</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_client_cert_blob"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_blob">
        <doc xml:whitespace="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" client certificate data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_phase2_client_cert_path"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_path">
        <doc xml:whitespace="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">path to the "phase 2" client certificate file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_client_cert_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_scheme">
        <doc xml:whitespace="preserve">Returns the scheme used to store the "phase 2" client certificate.  If the
returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scheme used to store the "phase 2" client certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
      </method>
      <method name="get_phase2_private_key_blob"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_blob">
        <doc xml:whitespace="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

WARNING: the phase2 private key property is not a "secret" property, and thus
unencrypted private key data may be readable by unprivileged users.  Private
keys should always be encrypted with a private key password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the "phase 2" private key data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_phase2_private_key_format"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_format">
        <doc xml:whitespace="preserve">#NMSetting8021x:phase2-private-key property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the data format of the "phase 2" private key data stored in the</doc>
          <type name="Setting8021xCKFormat" c:type="NMSetting8021xCKFormat"/>
        </return-value>
      </method>
      <method name="get_phase2_private_key_password"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_password">
        <doc xml:whitespace="preserve">previously set with nm_setting_802_1x_set_phase2_private_key() or the
#NMSetting8021x:phase2-private-key-password property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the private key password used to decrypt the private key if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_private_key_password_flags"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_password_flags">
        <doc xml:whitespace="preserve">#NMSetting8021x:phase2-private-key-password</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_phase2_private_key_path"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_path">
        <doc xml:whitespace="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">path to the "phase 2" private key file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_phase2_private_key_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_scheme">
        <doc xml:whitespace="preserve">Returns the scheme used to store the "phase 2" private key.  If the returned
scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scheme used to store the "phase 2" private key (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
      </method>
      <method name="get_phase2_subject_match"
              c:identifier="nm_setting_802_1x_get_phase2_subject_match">
        <doc xml:whitespace="preserve">the substring to be matched against the subject of the "phase 2"
authentication server certificate, or NULL no subject verification
is to be performed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSetting8021x:phase2-subject-match property. This is</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_pin" c:identifier="nm_setting_802_1x_get_pin">
        <doc xml:whitespace="preserve">by the #NMSetting8021x:pin property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the PIN used by the authentication method, if any, as specified</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_pin_flags"
              c:identifier="nm_setting_802_1x_get_pin_flags">
        <doc xml:whitespace="preserve">#NMSetting8021x:pin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_private_key_blob"
              c:identifier="nm_setting_802_1x_get_private_key_blob">
        <doc xml:whitespace="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

WARNING: the private key property is not a "secret" property, and thus
unencrypted private key data may be readable by unprivileged users.  Private
keys should always be encrypted with a private key password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the private key data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_private_key_format"
              c:identifier="nm_setting_802_1x_get_private_key_format">
        <doc xml:whitespace="preserve">#NMSetting8021x:private-key property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the data format of the private key data stored in the</doc>
          <type name="Setting8021xCKFormat" c:type="NMSetting8021xCKFormat"/>
        </return-value>
      </method>
      <method name="get_private_key_password"
              c:identifier="nm_setting_802_1x_get_private_key_password">
        <doc xml:whitespace="preserve">previously set with nm_setting_802_1x_set_private_key(), or the
#NMSetting8021x:private-key-password property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the private key password used to decrypt the private key if</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_private_key_password_flags"
              c:identifier="nm_setting_802_1x_get_private_key_password_flags">
        <doc xml:whitespace="preserve">#NMSetting8021x:private-key-password</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_private_key_path"
              c:identifier="nm_setting_802_1x_get_private_key_path">
        <doc xml:whitespace="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">path to the private key file</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_private_key_scheme"
              c:identifier="nm_setting_802_1x_get_private_key_scheme">
        <doc xml:whitespace="preserve">Returns the scheme used to store the private key.  If the returned scheme is
%NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scheme used to store the private key (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
      </method>
      <method name="get_subject_match"
              c:identifier="nm_setting_802_1x_get_subject_match">
        <doc xml:whitespace="preserve">substring to be matched against the subject of the authentication
server certificate, or NULL no subject verification is to be
performed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSetting8021x:subject-match property. This is the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_system_ca_certs"
              c:identifier="nm_setting_802_1x_get_system_ca_certs">
        <doc xml:whitespace="preserve">Sets the #NMSetting8021x:system-ca-certs property. The
#NMSetting8021x:ca-path and #NMSetting8021x:phase2-ca-path
properties are ignored if the #NMSetting8021x:system-ca-certs property is
TRUE, in which case a system-wide CA certificate directory specified at
compile time (using the --system-ca-path configure option) is used in place
of these properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if a system CA certificate path should be used, FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove_altsubject_match"
              c:identifier="nm_setting_802_1x_remove_altsubject_match">
        <doc xml:whitespace="preserve">Removes the allowed altSubjectName at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the altSubjectName match to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_eap_method"
              c:identifier="nm_setting_802_1x_remove_eap_method">
        <doc xml:whitespace="preserve">Removes the allowed EAP method at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the EAP method to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_remove_phase2_altsubject_match">
        <doc xml:whitespace="preserve">Removes the allowed "phase 2" altSubjectName at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the "phase 2" altSubjectName match to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ca_cert"
              c:identifier="nm_setting_802_1x_set_ca_cert"
              throws="1">
        <doc xml:whitespace="preserve">Reads a certificate from disk and sets the #NMSetting8021x:ca-cert property
with the raw certificate data if using the %NM_SETTING_802_1X_CK_SCHEME_BLOB
scheme, or with the path to the certificate file if using the
%NM_SETTING_802_1X_CK_SCHEME_PATH scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the CA certificate file (PEM or DER format).  The path must be UTF-8 encoded; use g_filename_to_utf8() to convert if needed.  Passing NULL with any @scheme clears the CA certificate.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_client_cert"
              c:identifier="nm_setting_802_1x_set_client_cert"
              throws="1">
        <doc xml:whitespace="preserve">Reads a certificate from disk and sets the #NMSetting8021x:client-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the client certificate file (PEM, DER, or PKCS#12 format).  The path must be UTF-8 encoded; use g_filename_to_utf8() to convert if needed.  Passing NULL with any @scheme clears the client certificate.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_ca_cert"
              c:identifier="nm_setting_802_1x_set_phase2_ca_cert"
              throws="1">
        <doc xml:whitespace="preserve">Reads a certificate from disk and sets the #NMSetting8021x:phase2-ca-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" CA certificate file (PEM or DER format).  The path must be UTF-8 encoded; use g_filename_to_utf8() to convert if needed.  Passing NULL with any @scheme clears the "phase2" CA certificate.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_client_cert"
              c:identifier="nm_setting_802_1x_set_phase2_client_cert"
              throws="1">
        <doc xml:whitespace="preserve">Reads a certificate from disk and sets the #NMSetting8021x:phase2-client-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" client certificate file (PEM, DER, or PKCS#12 format).  The path must be UTF-8 encoded; use g_filename_to_utf8() to convert if needed.  Passing NULL with any @scheme clears the "phase2" client certificate.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_private_key"
              c:identifier="nm_setting_802_1x_set_phase2_private_key"
              throws="1">
        <doc xml:whitespace="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

This function reads a private key from disk and sets the
#NMSetting8021x:phase2-private-key property with the private key file data if
using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the
private key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

If @password is given, this function attempts to decrypt the private key to
verify that @password is correct, and if it is, updates the
#NMSetting8021x:phase2-private-key-password property with the given
@password.  If the decryption is unsuccessful, %FALSE is returned, @error is
set, and no internal data is changed.  If no @password is given, the private
key is assumed to be valid, no decryption is performed, and the password may
be set at a later time.

WARNING: the "phase2" private key property is not a "secret" property, and
thus unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a private
key password to prevent unauthorized access to unencrypted private key data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" private key file (PEM, DER, or PKCS#12 format).  The path must be UTF-8 encoded; use g_filename_to_utf8() to convert if needed.  Passing NULL with any @scheme clears the private key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">password used to decrypt the private key, or %NULL if the password is unknown.  If the password is given but fails to decrypt the private key, an error is returned.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired storage scheme for the private key</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">on successful return, the type of the private key added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_private_key"
              c:identifier="nm_setting_802_1x_set_private_key"
              throws="1">
        <doc xml:whitespace="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

This function reads a private key from disk and sets the
#NMSetting8021x:private-key property with the private key file data if using
the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the private
key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

If @password is given, this function attempts to decrypt the private key to
verify that @password is correct, and if it is, updates the
#NMSetting8021x:private-key-password property with the given @password.  If
the decryption is unsuccessful, %FALSE is returned, @error is set, and no
internal data is changed.  If no @password is given, the private key is
assumed to be valid, no decryption is performed, and the password may be set
at a later time.

WARNING: the private key property is not a "secret" property, and thus
unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a private
key password to prevent unauthorized access to unencrypted private key data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation succeeded, FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the private key file (PEM, DER, or PKCS#12 format).  The path must be UTF-8 encoded; use g_filename_to_utf8() to convert if needed.  Passing NULL with any @scheme clears the private key.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">password used to decrypt the private key, or %NULL if the password is unknown.  If the password is given but fails to decrypt the private key, an error is returned.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">desired storage scheme for the private key</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">on successful return, the type of the private key added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <property name="altsubject-matches"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">List of strings to be matched against the altSubjectName of the
certificate presented by the authentication server. If the list
is empty, no verification of the server certificate's
altSubjectName is performed.</doc>
        <type/>
      </property>
      <property name="anonymous-identity"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Anonymous identity string for EAP authentication methods.  Used as the
unencrypted identity with EAP types that support different tunneled
identity like EAP-TTLS.</doc>
        <type name="utf8"/>
      </property>
      <property name="ca-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Contains the CA certificate if used by the EAP method specified in the
#NMSetting8021x:eap property.  Setting this property directly is
discouraged; use the nm_setting_802_1x_set_ca_cert() function instead.</doc>
        <type/>
      </property>
      <property name="ca-path" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">UTF-8 encoded path to a directory containing PEM or DER formatted
certificates to be added to the verification chain in addition to the
certificate specified in the #NMSetting8021x:ca-cert property.</doc>
        <type name="utf8"/>
      </property>
      <property name="client-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Contains the client certificate if used by the EAP method specified in
the #NMSetting8021x:eap property.  Setting this property directly is
discouraged; use the nm_setting_802_1x_set_client_cert() function instead.</doc>
        <type/>
      </property>
      <property name="eap"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The allowed EAP method to be used when authenticating to the network with
802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", and
"fast".  Each method requires different configuration using the
properties of this object; refer to wpa_supplicant documentation for the
allowed combinations.</doc>
        <type/>
      </property>
      <property name="identity" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Identity string for EAP authentication methods.  Often the user's
user or login name.</doc>
        <type name="utf8"/>
      </property>
      <property name="pac-file" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">UTF-8 encoded file path containing PAC for EAP-FAST.</doc>
        <type name="utf8"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Password used for EAP authentication methods. If both
#NMSetting8021x:password and #NMSetting8021x:password-raw are
specified, #NMSetting8021x:password is preferred.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSetting8021x:password:.</doc>
        <type name="guint"/>
      </property>
      <property name="password-raw"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Password used for EAP authentication methods delivered as a
UTF-8-encoded array of bytes. If both #NMSetting8021x:password
and #NMSetting8021x:password-raw are specified,
#NMSetting8021x:password is preferred.</doc>
        <type/>
      </property>
      <property name="password-raw-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSetting8021x:password-raw:.</doc>
        <type name="guint"/>
      </property>
      <property name="phase1-fast-provisioning"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Enables or disables in-line provisioning of EAP-FAST credentials when
FAST is specified as the EAP method in the #NMSetting8021x:eap property.
Recognized values are "0" (disabled), "1" (allow unauthenticated
provisioning), "2" (allow authenticated provisioning), and "3" (allow
both authenticated and unauthenticated provisioning).  See the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase1-peaplabel" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Forces use of the new PEAP label during key derivation.  Some RADIUS
servers may require forcing the new PEAP label to interoperate with
PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase1-peapver" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Forces which PEAP version is used when PEAP is set as the EAP method in
the #NMSetting8021x:eap property.  When unset, the version reported by
the server will be used.  Sometimes when using older RADIUS servers, it
is necessary to force the client to use a particular PEAP version.  To do
so, this property may be set to "0" or "1" to force that specific PEAP
version.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase2-altsubject-matches"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">List of strings to be matched against the altSubjectName of the
certificate presented by the authentication server during the
inner "phase 2" authentication. If the list is empty, no
verification of the server certificate's altSubjectName is
performed.</doc>
        <type/>
      </property>
      <property name="phase2-auth" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Specifies the allowed "phase 2" inner non-EAP authentication methods when
an EAP method that uses an inner TLS tunnel is specified in the
#NMSetting8021x:eap property.  Recognized non-EAP phase2 methods are
"pap", "chap", "mschap", "mschapv2", "gtc", "otp", "md5", and "tls".
Each 'phase 2' inner method requires specific parameters for successful
authentication; see the wpa_supplicant documentation for more details.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase2-autheap" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Specifies the allowed "phase 2" inner EAP-based authentication methods
when an EAP method that uses an inner TLS tunnel is specified in the
#NMSetting8021x:eap property.  Recognized EAP-based phase2 methods are
"md5", "mschapv2", "otp", "gtc", and "tls". Each 'phase 2' inner method
requires specific parameters for successful authentication; see the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase2-ca-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Contains the CA certificate if used by the EAP method specified in the
#NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap properties.
Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_ca_cert() function instead.</doc>
        <type/>
      </property>
      <property name="phase2-ca-path" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">UTF-8 encoded path to a directory containing PEM or DER formatted
certificates to be added to the verification chain in addition to the
certificate specified in the #NMSetting8021x:phase2-ca-cert property.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase2-client-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Contains the client certificate if used by the EAP method specified in
the #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap
properties.  Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_client_cert() function instead.</doc>
        <type/>
      </property>
      <property name="phase2-private-key"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Private key data used by "phase 2" inner authentication methods.

Contains the "phase 2" inner private key if the #NMSetting8021x:phase2-auth
or #NMSetting8021x:phase2-autheap property is set to 'tls'.  Setting this
property directly is discouraged; use the
nm_setting_802_1x_set_phase2_private_key() function instead.</doc>
        <type/>
      </property>
      <property name="phase2-private-key-password"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The password used to decrypt the private key specified in
#NMSetting8021x:phase2-private-key when the private key either uses the
path scheme, or if the private key is a PKCS#12 format key.  Setting this
property directly is not generally necessary except when returning
secrets to NetworkManager; it is generally set automatically when setting
the private key by the nm_setting_802_1x_set_phase2_private_key() function.</doc>
        <type name="utf8"/>
      </property>
      <property name="phase2-private-key-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSetting8021x:phase2-private-key-password:.</doc>
        <type name="guint"/>
      </property>
      <property name="phase2-subject-match"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Substring to be matched against the subject of the certificate
presented by the authentication server during the inner "phase
2" authentication. When unset, no verification of the
authentication server certificate's subject is performed.</doc>
        <type name="utf8"/>
      </property>
      <property name="private-key"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Contains the private key if the #NMSetting8021x:eap property is set to
'tls'.  Setting this property directly is discouraged; use the
nm_setting_802_1x_set_private_key() function instead.

WARNING: #NMSetting8021x:private-key is not a "secret" property, and thus
unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a
private key password to prevent unauthorized access to unencrypted
private key data.</doc>
        <type/>
      </property>
      <property name="private-key-password"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The password used to decrypt the private key specified in
#NMSetting8021x:private-key when the private key either uses the path
scheme, or if the private key is a PKCS#12 format key.  Setting this
property directly is not generally necessary except when returning
secrets to NetworkManager; it is generally set automatically when setting
the private key by the nm_setting_802_1x_set_private_key() function.</doc>
        <type name="utf8"/>
      </property>
      <property name="private-key-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSetting8021x:private-key-password:.</doc>
        <type name="guint"/>
      </property>
      <property name="subject-match" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Substring to be matched against the subject of the certificate
presented by the authentication server. When unset, no
verification of the authentication server certificate's subject
is performed.</doc>
        <type name="utf8"/>
      </property>
      <property name="system-ca-certs"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When TRUE, overrides #NMSetting8021x:ca-path and
#NMSetting8021x:phase2-ca-path properties using the system CA directory
specified at configure time with the --system-ca-path switch.  The
certificates in this directory are added to the verification chain in
addition to any certificates specified by the #NMSetting8021x:ca-cert
and #NMSetting8021x:phase2-ca-cert properties.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <enumeration name="Setting8021xCKFormat"
                 glib:type-name="NMSetting8021xCKFormat"
                 glib:get-type="nm_setting_802_1x_ck_format_get_type"
                 c:type="NMSetting8021xCKFormat">
      <doc xml:whitespace="preserve">#NMSetting8021xCKFormat values indicate the general type of a certificate
or private key</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_UNKNOWN"
              glib:nick="unknown"/>
      <member name="x509"
              value="1"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_X509"
              glib:nick="x509"/>
      <member name="raw_key"
              value="2"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_RAW_KEY"
              glib:nick="raw-key"/>
      <member name="pkcs12"
              value="3"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_PKCS12"
              glib:nick="pkcs12"/>
    </enumeration>
    <enumeration name="Setting8021xCKScheme"
                 glib:type-name="NMSetting8021xCKScheme"
                 glib:get-type="nm_setting_802_1x_ck_scheme_get_type"
                 c:type="NMSetting8021xCKScheme">
      <doc xml:whitespace="preserve">#NMSetting8021xCKScheme values indicate how a certificate or private key is
stored in the setting properties, either as a blob of the item's data, or as
a path to a certificate or private key file on the filesystem</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_UNKNOWN"
              glib:nick="unknown"/>
      <member name="blob"
              value="1"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_BLOB"
              glib:nick="blob"/>
      <member name="path"
              value="2"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_PATH"
              glib:nick="path"/>
    </enumeration>
    <record name="Setting8021xClass"
            c:type="NMSetting8021xClass"
            glib:is-gtype-struct-for="Setting8021x">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="Setting8021xError"
                 glib:type-name="NMSetting8021xError"
                 glib:get-type="nm_setting_802_1x_error_get_type"
                 c:type="NMSetting8021xError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_802_1X_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_802_1X_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_802_1X_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_802_1x_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSetting8021x if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSetting8021x errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingBluetooth"
           c:symbol-prefix="setting_bluetooth"
           c:type="NMSettingBluetooth"
           parent="Setting"
           glib:type-name="NMSettingBluetooth"
           glib:get-type="nm_setting_bluetooth_get_type"
           glib:type-struct="SettingBluetoothClass">
      <constructor name="new" c:identifier="nm_setting_bluetooth_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingBluetooth object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingBluetooth object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_bdaddr" c:identifier="nm_setting_bluetooth_get_bdaddr">
        <doc xml:whitespace="preserve">Gets the Bluetooth address of the remote device which this setting
describes a connection to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the Bluetooth address</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_setting_bluetooth_get_connection_type">
        <doc xml:whitespace="preserve">Returns the connection method for communicating with the remote device (i.e.
either DUN to a DUN-capable device or PANU to a NAP-capable device).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the type, either %NM_SETTING_BLUETOOTH_PANU or %NM_SETTING_BLUETOOTH_DUN</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <property name="bdaddr"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The Bluetooth address of the device.</doc>
        <type/>
      </property>
      <property name="type" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Either 'dun' for Dial-Up Networking connections or 'panu' for Personal
Area Networking connections to devices supporting the NAP profile.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBluetoothClass"
            c:type="NMSettingBluetoothClass"
            glib:is-gtype-struct-for="SettingBluetooth">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingBluetoothError"
                 glib:type-name="NMSettingBluetoothError"
                 glib:get-type="nm_setting_bluetooth_error_get_type"
                 c:type="NMSettingBluetoothError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="TypeSettingNotFound"
              value="3"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_TYPE_SETTING_NOT_FOUND"
              glib:nick="TypeSettingNotFound"/>
      <function name="quark" c:identifier="nm_setting_bluetooth_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingBluetooth if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingBluetooth errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingBond"
           c:symbol-prefix="setting_bond"
           c:type="NMSettingBond"
           parent="Setting"
           glib:type-name="NMSettingBond"
           glib:get-type="nm_setting_bond_get_type"
           glib:type-struct="SettingBondClass">
      <constructor name="new" c:identifier="nm_setting_bond_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingBond object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingBond object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_option" c:identifier="nm_setting_bond_add_option">
        <doc xml:whitespace="preserve">Add an option to the table.  The option is compared to an internal list
of allowed options.  Option names may contain only alphanumeric characters
(ie [a-zA-Z0-9]).  Adding a new name replaces any existing name/value pair
that may already exist.

list, %FALSE if it was not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the option was valid and was added to the internal option</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name for the option</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">value for the option</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_bond_get_interface_name">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingBond:interface-name property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_num_options"
              c:identifier="nm_setting_bond_get_num_options">
        <doc xml:whitespace="preserve">Returns the number of options that should be set for this bond when it
is activated. This can be used to retrieve each option individually
using nm_setting_bond_get_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bonding options</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_option" c:identifier="nm_setting_bond_get_option">
        <doc xml:whitespace="preserve">Given an index, return the value of the bonding option at that index.  Indexes
are *not* guaranteed to be static across modifications to options done by
nm_setting_bond_add_option() and nm_setting_bond_remove_option(),
and should not be used to refer to options except for short periods of time
such as during option iteration.

%FALSE if the index was invalid (ie, greater than the number of options
currently held by the setting)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success if the index was valid and an option was found,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of the desired option, from 0 to nm_setting_bond_get_num_options() - 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">on return, the name of the bonding option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">on return, the value of the name of the bonding option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_option_by_name"
              c:identifier="nm_setting_bond_get_option_by_name">
        <doc xml:whitespace="preserve">Returns the value associated with the bonding option specified by
@name, if it exists.

setting; the value is owned by the setting and must not be modified</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value, or %NULL if the key/value pair was never added to the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the option name for which to retrieve the value</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_option_default"
              c:identifier="nm_setting_bond_get_option_default">
        <doc xml:whitespace="preserve">the #NMSettingBond:options property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the bond option if not overridden by an entry in</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the option</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_options"
              c:identifier="nm_setting_bond_get_valid_options"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a list of valid bond options.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a NULL-terminated array of strings of valid bond options.</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="remove_option"
              c:identifier="nm_setting_bond_remove_option">
        <doc xml:whitespace="preserve">Remove the bonding option referenced by @name from the internal option
list.

list, %FALSE if it was not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the option was found and removed from the internal option</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the option to remove</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="interface-name" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the virtual in-kernel bonding network interface</doc>
        <type name="utf8"/>
      </property>
      <property name="options"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Dictionary of key/value pairs of bonding options.  Both keys
and values must be strings. Option names must contain only
alphanumeric characters (ie, [a-zA-Z0-9]).</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBondClass"
            c:type="NMSettingBondClass"
            glib:is-gtype-struct-for="SettingBond">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingBondError"
                 glib:type-name="NMSettingBondError"
                 glib:get-type="nm_setting_bond_error_get_type"
                 c:type="NMSettingBondError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_BOND_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_BOND_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_BOND_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="InvalidOption"
              value="3"
              c:identifier="NM_SETTING_BOND_ERROR_INVALID_OPTION"
              glib:nick="InvalidOption"/>
      <member name="MissingOption"
              value="4"
              c:identifier="NM_SETTING_BOND_ERROR_MISSING_OPTION"
              glib:nick="MissingOption"/>
      <function name="quark" c:identifier="nm_setting_bond_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingBond if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingBond errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingCdma"
           c:symbol-prefix="setting_cdma"
           c:type="NMSettingCdma"
           parent="Setting"
           glib:type-name="NMSettingCdma"
           glib:get-type="nm_setting_cdma_get_type"
           glib:type-struct="SettingCdmaClass">
      <constructor name="new" c:identifier="nm_setting_cdma_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingCdma object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingCdma object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_number" c:identifier="nm_setting_cdma_get_number">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingCdma:number property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password" c:identifier="nm_setting_cdma_get_password">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingCdma:password property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_cdma_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingCdma:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_username" c:identifier="nm_setting_cdma_get_username">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingCdma:username property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <property name="number" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The number to dial to establish the connection to the CDMA-based mobile
broadband network, if any.  If not specified, the default number (#777)
is used when required.</doc>
        <type name="utf8"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The password used to authenticate with the network, if required.  Many
providers do not require a password, or accept any password.  But if a
password is required, it is specified here.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingCdma:password:.</doc>
        <type name="guint"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The username used to authenticate with the network, if required.  Many
providers do not require a username, or accept any username.  But if a
username is required, it is specified here.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingCdmaClass"
            c:type="NMSettingCdmaClass"
            glib:is-gtype-struct-for="SettingCdma">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingCdmaError"
                 glib:type-name="NMSettingCdmaError"
                 glib:get-type="nm_setting_cdma_error_get_type"
                 c:type="NMSettingCdmaError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_CDMA_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_CDMA_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_CDMA_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="MissingSerialSetting"
              value="3"
              c:identifier="NM_SETTING_CDMA_ERROR_MISSING_SERIAL_SETTING"
              glib:nick="MissingSerialSetting"/>
      <function name="quark" c:identifier="nm_setting_cdma_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingCdma if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingCdma errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="SettingClass"
            c:type="NMSettingClass"
            glib:is-gtype-struct-for="Setting">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="verify">
        <callback name="verify" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the setting is valid, %FALSE if it is not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="all_settings" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GSList of all settings in the connection from which @setting came</doc>
              <type name="GLib.SList" c:type="GSList*">
                <type name="Setting"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="need_secrets">
        <callback name="need_secrets">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GPtrArray containing the property names of secrets of the</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_one_secret">
        <callback name="update_one_secret" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_secret_flags">
        <callback name="get_secret_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="secret_name" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="verify_secret" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="out_flags" transfer-ownership="none">
              <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_secret_flags">
        <callback name="set_secret_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="secret_name" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
            <parameter name="verify_secret" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="compare_property">
        <callback name="compare_property">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="other" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="prop_spec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_secrets_with_flags" introspectable="0">
        <callback name="clear_secrets_with_flags" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="3">
              <type name="SettingClearSecretsWithFlagsFn"
                    c:type="NMSettingClearSecretsWithFlagsFn"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_virtual_iface_name">
        <callback name="get_virtual_iface_name">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">Name of the virtual interface or %NULL if the setting does not</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SettingClearSecretsWithFlagsFn"
              c:type="NMSettingClearSecretsWithFlagsFn">
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE to clear the secret, %FALSE to not clear the secret</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setting for which secrets are being iterated</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </parameter>
        <parameter name="secret" transfer-ownership="none">
          <doc xml:whitespace="preserve">The secret's name</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">The secret's flags, eg %NM_SETTING_SECRET_FLAG_AGENT_OWNED</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">User data passed to nm_connection_clear_secrets_with_flags()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SettingCompareFlags"
                 glib:type-name="NMSettingCompareFlags"
                 glib:get-type="nm_setting_compare_flags_get_type"
                 c:type="NMSettingCompareFlags">
      <doc xml:whitespace="preserve">These flags modify the comparison behavior when comparing two settings or
two connections.</doc>
      <member name="exact"
              value="0"
              c:identifier="NM_SETTING_COMPARE_FLAG_EXACT"
              glib:nick="exact"/>
      <member name="fuzzy"
              value="1"
              c:identifier="NM_SETTING_COMPARE_FLAG_FUZZY"
              glib:nick="fuzzy"/>
      <member name="ignore_id"
              value="2"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_ID"
              glib:nick="ignore-id"/>
      <member name="ignore_secrets"
              value="4"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS"
              glib:nick="ignore-secrets"/>
      <member name="ignore_agent_owned_secrets"
              value="8"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS"
              glib:nick="ignore-agent-owned-secrets"/>
      <member name="ignore_not_saved_secrets"
              value="16"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS"
              glib:nick="ignore-not-saved-secrets"/>
    </enumeration>
    <class name="SettingConnection"
           c:symbol-prefix="setting_connection"
           c:type="NMSettingConnection"
           parent="Setting"
           glib:type-name="NMSettingConnection"
           glib:get-type="nm_setting_connection_get_type"
           glib:type-struct="SettingConnectionClass">
      <doc xml:whitespace="preserve">The NMSettingConnection struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <constructor name="new" c:identifier="nm_setting_connection_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingConnection object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingConnection object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_permission"
              c:identifier="nm_setting_connection_add_permission">
        <doc xml:whitespace="preserve">Adds a permission to the connection's permission list.  At this time, only
the "user" permission type is supported, and @pitem must be a username. See
#NMSettingConnection:permissions: for more details.

list, FALSE if @ptype or @pitem was invalid or it the permission was already
present in the list</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the permission was unique and was successfully added to the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="ptype" transfer-ownership="none">
            <doc xml:whitespace="preserve">the permission type; at this time only "user" is supported</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="pitem" transfer-ownership="none">
            <doc xml:whitespace="preserve">the permission item formatted as required for @ptype</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="detail" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">unused at this time; must be %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_autoconnect"
              c:identifier="nm_setting_connection_get_autoconnect">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:autoconnect property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection's autoconnect behavior</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_setting_connection_get_connection_type">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:type property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection type</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_id" c:identifier="nm_setting_connection_get_id">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:id property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection ID</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_master"
              c:identifier="nm_setting_connection_get_master">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:master property of the connection.

connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">interface name of the master device or UUID of the master</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_num_permissions"
              c:identifier="nm_setting_connection_get_num_permissions">
        <doc xml:whitespace="preserve">Returns the number of entires in the #NMSettingConnection:permissions
property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of permissions entires</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_permission"
              c:identifier="nm_setting_connection_get_permission">
        <doc xml:whitespace="preserve">Retrieve one of the entries of the #NMSettingConnection:permissions property
of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a permission was returned, %FALSE if @idx was invalid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the zero-based index of the permissions entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_ptype" transfer-ownership="none">
            <doc xml:whitespace="preserve">on return, the permission type (at this time, always "user")</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="out_pitem" transfer-ownership="none">
            <doc xml:whitespace="preserve">on return, the permission item (formatted accoring to @ptype, see #NMSettingConnection:permissions for more detail</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="out_detail" transfer-ownership="none">
            <doc xml:whitespace="preserve">on return, the permission detail (at this time, always NULL)</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_read_only"
              c:identifier="nm_setting_connection_get_read_only">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:read-only property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is read-only, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_slave_type"
              c:identifier="nm_setting_connection_get_slave_type">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:slave-type property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of slave this connection is, if any</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_timestamp"
              c:identifier="nm_setting_connection_get_timestamp">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:timestamp property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection's timestamp</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_uuid" c:identifier="nm_setting_connection_get_uuid">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:uuid property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection UUID</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_zone" c:identifier="nm_setting_connection_get_zone">
        <doc xml:whitespace="preserve">Returns the #NMSettingConnection:zone property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the trust level of a connection</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="is_slave_type"
              c:identifier="nm_setting_connection_is_slave_type">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if connection is of the given slave @type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the setting name (ie #NM_SETTING_BOND_SETTING_NAME) to be matched against @setting's slave type</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="permissions_user_allowed"
              c:identifier="nm_setting_connection_permissions_user_allowed">
        <doc xml:whitespace="preserve">Checks whether the given username is allowed to view/access this connection.

%FALSE if the given user is not allowed to view this connection</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the requested user is allowed to view this connection,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user name to check permissions for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_permission"
              c:identifier="nm_setting_connection_remove_permission">
        <doc xml:whitespace="preserve">Removes the permission at index @idx from the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the zero-based index of the permission to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <property name="autoconnect"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not the connection should be automatically connected by
NetworkManager when the resources for the connection are available.
%TRUE to automatically activate the connection, %FALSE to require manual
intervention to activate the connection.  Defaults to %TRUE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="id" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A human readable unique idenfier for the connection, like "Work WiFi" or
"T-Mobile 3G".</doc>
        <type name="utf8"/>
      </property>
      <property name="master" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Interface name of the master device or UUID of the master connection.</doc>
        <type name="utf8"/>
      </property>
      <property name="permissions"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">An array of strings defining what access a given user has to this
connection.  If this is NULL or empty, all users are allowed to access
this connection.  Otherwise a user is allowed to access this connection
if and only if they are in this list. Each entry is of the form
"[type]:[id]:[reserved]", for example:

user:dcbw:blah

At this time only the 'user' [type] is allowed.  Any other values are
ignored and reserved for future use.  [id] is the username that this
permission refers to, which may not contain the ':' character. Any
[reserved] information present must be ignored and is reserved for
future use.  All of [type], [id], and [reserved] must be valid UTF-8.</doc>
        <type/>
      </property>
      <property name="read-only"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the connection can be modified using the providing settings
service's D-Bus interface with the right privileges, or %FALSE
if the connection is read-only and cannot be modified.</doc>
        <type name="gboolean"/>
      </property>
      <property name="slave-type" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Setting name describing the type of slave device (ie
#NM_SETTING_BOND_SETTING_NAME) or NULL if this connection is not a slave.</doc>
        <type name="utf8"/>
      </property>
      <property name="timestamp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The time, in seconds since the Unix Epoch, that the connection was last
_successfully_ fully activated.</doc>
        <type name="guint64"/>
      </property>
      <property name="type" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The general hardware type of the device used for the network connection,
contains the name of the #NMSetting object that describes that hardware
type's parameters.  For example, for WiFi devices, the name of the
#NMSettingWireless setting.</doc>
        <type name="utf8"/>
      </property>
      <property name="uuid" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A universally unique idenfier for the connection, for example generated
with libuuid.  Should be assigned when the connection is created, and
never changed as long as the connection still applies to the same
network.  For example, should not be changed when the
#NMSettingConnection:id or #NMSettingIP4Config changes, but might need
to be re-created when the WiFi SSID, mobile broadband network provider,
or #NMSettingConnection:type changes.

The UUID must be in the format '2815492f-7e56-435e-b2e9-246bd7cdc664'
(ie, contains only hexadecimal characters and '-').  A suitable UUID may
be generated by nm_utils_uuid_generate() or
nm_utils_uuid_generate_from_string().</doc>
        <type name="utf8"/>
      </property>
      <property name="zone"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The trust level of a the connection.
Free form case-insensitive string (for example "Home", "Work", "Public").
NULL or unspecified zone means the connection will be placed in the
default zone as defined by the firewall.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingConnectionClass"
            c:type="NMSettingConnectionClass"
            glib:is-gtype-struct-for="SettingConnection">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingConnectionError"
                 glib:type-name="NMSettingConnectionError"
                 glib:get-type="nm_setting_connection_error_get_type"
                 c:type="NMSettingConnectionError">
      <doc xml:whitespace="preserve">Describes errors that may result from operations involving a
#NMSettingConnection.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_CONNECTION_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_CONNECTION_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_CONNECTION_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="TypeSettingNotFound"
              value="3"
              c:identifier="NM_SETTING_CONNECTION_ERROR_TYPE_SETTING_NOT_FOUND"
              glib:nick="TypeSettingNotFound"/>
      <member name="IpConfigNotAllowed"
              value="4"
              c:identifier="NM_SETTING_CONNECTION_ERROR_IP_CONFIG_NOT_ALLOWED"
              glib:nick="IpConfigNotAllowed"/>
      <function name="quark" c:identifier="nm_setting_connection_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingConnection if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingConnection errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingDiffResult"
                 glib:type-name="NMSettingDiffResult"
                 glib:get-type="nm_setting_diff_result_get_type"
                 c:type="NMSettingDiffResult">
      <doc xml:whitespace="preserve">These values indicate the result of a setting difference operation.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_DIFF_RESULT_UNKNOWN"
              glib:nick="unknown"/>
      <member name="in_a"
              value="1"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_A"
              glib:nick="in-a"/>
      <member name="in_b"
              value="2"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_B"
              glib:nick="in-b"/>
    </enumeration>
    <enumeration name="SettingError"
                 glib:type-name="NMSettingError"
                 glib:get-type="nm_setting_error_get_type"
                 c:type="NMSettingError">
      <doc xml:whitespace="preserve">Describes errors that may result from operations involving a #NMSetting.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="PropertyNotFound"
              value="1"
              c:identifier="NM_SETTING_ERROR_PROPERTY_NOT_FOUND"
              glib:nick="PropertyNotFound"/>
      <member name="PropertyNotSecret"
              value="2"
              c:identifier="NM_SETTING_ERROR_PROPERTY_NOT_SECRET"
              glib:nick="PropertyNotSecret"/>
      <member name="PropertyTypeMismatch"
              value="3"
              c:identifier="NM_SETTING_ERROR_PROPERTY_TYPE_MISMATCH"
              glib:nick="PropertyTypeMismatch"/>
      <function name="quark" c:identifier="nm_setting_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSetting if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for NMSetting errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingGsm"
           c:symbol-prefix="setting_gsm"
           c:type="NMSettingGsm"
           parent="Setting"
           glib:type-name="NMSettingGsm"
           glib:get-type="nm_setting_gsm_get_type"
           glib:type-struct="SettingGsmClass">
      <constructor name="new" c:identifier="nm_setting_gsm_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingGsm object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingGsm object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_allowed_bands"
              c:identifier="nm_setting_gsm_get_allowed_bands">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:allowed-bands property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_apn" c:identifier="nm_setting_gsm_get_apn">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:apn property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_home_only" c:identifier="nm_setting_gsm_get_home_only">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:home-only property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_network_id"
              c:identifier="nm_setting_gsm_get_network_id">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:network-id property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_network_type"
              c:identifier="nm_setting_gsm_get_network_type">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:network-type property of the setting</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_number" c:identifier="nm_setting_gsm_get_number">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:number property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password" c:identifier="nm_setting_gsm_get_password">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:password property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_gsm_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingGsm:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_pin" c:identifier="nm_setting_gsm_get_pin">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:pin property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_pin_flags" c:identifier="nm_setting_gsm_get_pin_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingGsm:pin</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_username" c:identifier="nm_setting_gsm_get_username">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingGsm:username property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <property name="allowed-bands"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Bitfield of allowed frequency bands.  Note that not all devices allow
frequency band control.  Permitted values are those specified by
#NMSettingGsmNetworkBand.</doc>
        <type name="guint"/>
      </property>
      <property name="apn" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The GPRS Access Point Name specifying the APN used when establishing a
data session with the GSM-based network.  The APN often determines how
the user will be billed for their network usage and whether the user has
access to the Internet or just a provider-specific walled-garden, so it
is important to use the correct APN for the user's mobile broadband plan.
The APN may only be composed of the characters a-z, 0-9, ., and - per
GSM 03.60 Section 14.9.</doc>
        <type name="utf8"/>
      </property>
      <property name="home-only" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">When TRUE, only connections to the home network will be allowed.
Connections to roaming networks will not be made.</doc>
        <type name="gboolean"/>
      </property>
      <property name="network-id" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Network ID (GSM LAI format, ie MCC-MNC) to force specific network
registration.  If the Network ID is specified, NetworkManager will
attempt to force the device to register only on the specified network.
This can be used to ensure that the device does not roam when direct
roaming control of the device is not otherwise possible.</doc>
        <type name="utf8"/>
      </property>
      <property name="network-type"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Network preference to force the device to only use specific network
technologies.  Permitted values are those specified by
#NMSettingGsmNetworkType.  Note that not all devices allow network
preference control.</doc>
        <type name="gint"/>
      </property>
      <property name="number" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Number to dial when establishing a PPP data session with the GSM-based
mobile broadband network.  Many modems do not require PPP for connections
to the mobile network and thus this property should be left blank, which
allows NetworkManager to select the appropriate settings automatically.</doc>
        <type name="utf8"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The password used to authenticate with the network, if required.  Many
providers do not require a password, or accept any password.  But if a
password is required, it is specified here.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingGsm:password:.</doc>
        <type name="guint"/>
      </property>
      <property name="pin" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the SIM is locked with a PIN it must be unlocked before any other
operations are requested.  Specify the PIN here to allow operation of
the device.</doc>
        <type name="utf8"/>
      </property>
      <property name="pin-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingGsm:pin.</doc>
        <type name="guint"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The username used to authenticate with the network, if required.  Many
providers do not require a username, or accept any username.  But if a
username is required, it is specified here.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingGsmClass"
            c:type="NMSettingGsmClass"
            glib:is-gtype-struct-for="SettingGsm">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingGsmError"
                 glib:type-name="NMSettingGsmError"
                 glib:get-type="nm_setting_gsm_error_get_type"
                 c:type="NMSettingGsmError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_GSM_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_GSM_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_GSM_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="MissingSerialSetting"
              value="3"
              c:identifier="NM_SETTING_GSM_ERROR_MISSING_SERIAL_SETTING"
              glib:nick="MissingSerialSetting"/>
      <function name="quark" c:identifier="nm_setting_gsm_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingGsm if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingGsm errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingGsmNetworkBand"
                 glib:type-name="NMSettingGsmNetworkBand"
                 glib:get-type="nm_setting_gsm_network_band_get_type"
                 c:type="NMSettingGsmNetworkBand">
      <doc xml:whitespace="preserve">#NMSettingGsmNetworkBand values indicate the allowed frequency bands
the device may use when connecting to this network.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_GSM_BAND_UNKNOWN"
              glib:nick="unknown"/>
      <member name="any"
              value="1"
              c:identifier="NM_SETTING_GSM_BAND_ANY"
              glib:nick="any"/>
      <member name="egsm"
              value="2"
              c:identifier="NM_SETTING_GSM_BAND_EGSM"
              glib:nick="egsm"/>
      <member name="dcs"
              value="4"
              c:identifier="NM_SETTING_GSM_BAND_DCS"
              glib:nick="dcs"/>
      <member name="pcs"
              value="8"
              c:identifier="NM_SETTING_GSM_BAND_PCS"
              glib:nick="pcs"/>
      <member name="g850"
              value="16"
              c:identifier="NM_SETTING_GSM_BAND_G850"
              glib:nick="g850"/>
      <member name="u2100"
              value="32"
              c:identifier="NM_SETTING_GSM_BAND_U2100"
              glib:nick="u2100"/>
      <member name="u1800"
              value="64"
              c:identifier="NM_SETTING_GSM_BAND_U1800"
              glib:nick="u1800"/>
      <member name="u17iv"
              value="128"
              c:identifier="NM_SETTING_GSM_BAND_U17IV"
              glib:nick="u17iv"/>
      <member name="u800"
              value="256"
              c:identifier="NM_SETTING_GSM_BAND_U800"
              glib:nick="u800"/>
      <member name="u850"
              value="512"
              c:identifier="NM_SETTING_GSM_BAND_U850"
              glib:nick="u850"/>
      <member name="u900"
              value="1024"
              c:identifier="NM_SETTING_GSM_BAND_U900"
              glib:nick="u900"/>
      <member name="u17ix"
              value="2048"
              c:identifier="NM_SETTING_GSM_BAND_U17IX"
              glib:nick="u17ix"/>
      <member name="u1900"
              value="4096"
              c:identifier="NM_SETTING_GSM_BAND_U1900"
              glib:nick="u1900"/>
      <member name="u2600"
              value="8192"
              c:identifier="NM_SETTING_GSM_BAND_U2600"
              glib:nick="u2600"/>
    </enumeration>
    <enumeration name="SettingGsmNetworkType"
                 glib:type-name="NMSettingGsmNetworkType"
                 glib:get-type="nm_setting_gsm_network_type_get_type"
                 c:type="NMSettingGsmNetworkType">
      <doc xml:whitespace="preserve">#NMSettingGsmNetworkType values indicate the allowed access technologies
the device may use when connecting to this network.</doc>
      <member name="any"
              value="-1"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_ANY"
              glib:nick="any"/>
      <member name="umts_hspa"
              value="0"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_UMTS_HSPA"
              glib:nick="umts-hspa"/>
      <member name="gprs_edge"
              value="1"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_GPRS_EDGE"
              glib:nick="gprs-edge"/>
      <member name="prefer_umts_hspa"
              value="2"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_PREFER_UMTS_HSPA"
              glib:nick="prefer-umts-hspa"/>
      <member name="prefer_gprs_edge"
              value="3"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_PREFER_GPRS_EDGE"
              glib:nick="prefer-gprs-edge"/>
    </enumeration>
    <enumeration name="SettingHashFlags"
                 glib:type-name="NMSettingHashFlags"
                 glib:get-type="nm_setting_hash_flags_get_type"
                 c:type="NMSettingHashFlags">
      <doc xml:whitespace="preserve">These flags determine which properties are added to the resulting hash
when calling nm_setting_to_hash().</doc>
      <member name="all"
              value="0"
              c:identifier="NM_SETTING_HASH_FLAG_ALL"
              glib:nick="all"/>
      <member name="no_secrets"
              value="1"
              c:identifier="NM_SETTING_HASH_FLAG_NO_SECRETS"
              glib:nick="no-secrets"/>
      <member name="only_secrets"
              value="2"
              c:identifier="NM_SETTING_HASH_FLAG_ONLY_SECRETS"
              glib:nick="only-secrets"/>
    </enumeration>
    <class name="SettingIP4Config"
           c:symbol-prefix="setting_ip4_config"
           c:type="NMSettingIP4Config"
           parent="Setting"
           glib:type-name="NMSettingIP4Config"
           glib:get-type="nm_setting_ip4_config_get_type"
           glib:type-struct="SettingIP4ConfigClass">
      <constructor name="new" c:identifier="nm_setting_ip4_config_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingIP4Config object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingIP4Config object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_address"
              c:identifier="nm_setting_ip4_config_add_address">
        <doc xml:whitespace="preserve">Adds a new IPv4 address and associated information to the setting.  The
given address is duplicated internally and is not changed by this function.

known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the address was added; %FALSE if the address was already</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new address to add</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns" c:identifier="nm_setting_ip4_config_add_dns">
        <doc xml:whitespace="preserve">Adds a new DNS server to the setting.

known</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the DNS server was added; %FALSE if the server was already</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dns" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv4 address (network byte order) of the DNS server to add</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns_search"
              c:identifier="nm_setting_ip4_config_add_dns_search">
        <doc xml:whitespace="preserve">Adds a new DNS search domain to the setting.

domain was already known</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the DNS search domain was added; %FALSE if the search</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:whitespace="preserve">the search domain to add</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_route" c:identifier="nm_setting_ip4_config_add_route">
        <doc xml:whitespace="preserve">Adds a new IPv4 route and associated information to the setting.  The
given route is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the route was added; %FALSE if the route was already known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="route" transfer-ownership="none">
            <doc xml:whitespace="preserve">the route to add</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_addresses"
              c:identifier="nm_setting_ip4_config_clear_addresses">
        <doc xml:whitespace="preserve">Removes all configured addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_dns" c:identifier="nm_setting_ip4_config_clear_dns">
        <doc xml:whitespace="preserve">Removes all configured DNS servers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_dns_searches"
              c:identifier="nm_setting_ip4_config_clear_dns_searches">
        <doc xml:whitespace="preserve">Removes all configured DNS search domains.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_routes"
              c:identifier="nm_setting_ip4_config_clear_routes">
        <doc xml:whitespace="preserve">Removes all configured routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_address"
              c:identifier="nm_setting_ip4_config_get_address">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the address at index @i</doc>
          <type name="IP4Address" c:type="NMIP4Address*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the address to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dhcp_client_id"
              c:identifier="nm_setting_ip4_config_get_dhcp_client_id">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-client-id
property.

addresses via DHCP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the configured Client ID to send to the DHCP server when requesting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_dhcp_hostname"
              c:identifier="nm_setting_ip4_config_get_dhcp_hostname">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-hostname
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the configured hostname to send to the DHCP server</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_dhcp_send_hostname"
              c:identifier="nm_setting_ip4_config_get_dhcp_send_hostname">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-send-hostname
property.

DHCP server when requesting addresses to allow the server to automatically
update DNS information for this machine.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if NetworkManager should send the machine hostname to the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_dns" c:identifier="nm_setting_ip4_config_get_dns">
        <doc xml:whitespace="preserve">@i</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv4 address (network byte order) of the DNS server at index</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS server to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns_search"
              c:identifier="nm_setting_ip4_config_get_dns_search">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the DNS search domain at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS search domain to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_dns"
              c:identifier="nm_setting_ip4_config_get_ignore_auto_dns">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:ignore-auto-dns
property.

should be ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if automatically configured (ie via DHCP) DNS information</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_ignore_auto_routes"
              c:identifier="nm_setting_ip4_config_get_ignore_auto_routes">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:ignore-auto-routes
property.

ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if automatically configured (ie via DHCP) routes should be</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_may_fail"
              c:identifier="nm_setting_ip4_config_get_may_fail">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:may-fail
property.

for the connection to succeed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection doesn't require IPv4 addressing to complete</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_method"
              c:identifier="nm_setting_ip4_config_get_method">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingIP4Config:method property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_never_default"
              c:identifier="nm_setting_ip4_config_get_never_default">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP4Config:never-default
property.

for IPv4 addressing</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection should never be the default connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_num_addresses"
              c:identifier="nm_setting_ip4_config_get_num_addresses">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_dns"
              c:identifier="nm_setting_ip4_config_get_num_dns">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured DNS servers</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_dns_searches"
              c:identifier="nm_setting_ip4_config_get_num_dns_searches">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured DNS search domains</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_routes"
              c:identifier="nm_setting_ip4_config_get_num_routes">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured routes</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_route" c:identifier="nm_setting_ip4_config_get_route">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the route at index @i</doc>
          <type name="IP4Route" c:type="NMIP4Route*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the route to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_address"
              c:identifier="nm_setting_ip4_config_remove_address">
        <doc xml:whitespace="preserve">Removes the address at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the address to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns"
              c:identifier="nm_setting_ip4_config_remove_dns">
        <doc xml:whitespace="preserve">Removes the DNS server at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS server to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search"
              c:identifier="nm_setting_ip4_config_remove_dns_search">
        <doc xml:whitespace="preserve">Removes the DNS search domain at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS search domain</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route"
              c:identifier="nm_setting_ip4_config_remove_route">
        <doc xml:whitespace="preserve">Removes the route at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the route</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <property name="addresses"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Array of IPv4 address structures.  Each IPv4 address structure is
composed of 3 32-bit values; the first being the IPv4 address (network
byte order), the second the prefix (1 - 32), and last the IPv4 gateway
(network byte order). The gateway may be left as 0 if no gateway exists
for that subnet.  For the 'auto' method, given IP addresses are appended
to those returned by automatic configuration.  Addresses cannot be used
with the 'shared', 'link-local', or 'disabled' methods as addressing is
either automatic or disabled with these methods.</doc>
        <type/>
      </property>
      <property name="dhcp-client-id" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string sent to the DHCP server to identify the local machine which the
DHCP server may use to cusomize the DHCP lease and options.</doc>
        <type name="utf8"/>
      </property>
      <property name="dhcp-hostname" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the #NMSettingIP4Config:dhcp-send-hostname property is TRUE, then the
specified name will be sent to the DHCP server when acquiring a lease.</doc>
        <type name="utf8"/>
      </property>
      <property name="dhcp-send-hostname"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, a hostname is sent to the DHCP server when acquiring a lease.
Some DHCP servers use this hostname to update DNS databases, essentially
providing a static hostname for the computer.  If
#NMSettingIP4Config:dhcp-hostname is empty and this property is TRUE,
the current persistent hostname of the computer is sent.</doc>
        <type name="gboolean"/>
      </property>
      <property name="dns"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">List of DNS servers (network byte order).  For the 'auto' method, these
DNS servers are appended to those (if any) returned by automatic
configuration.  DNS servers cannot be used with the 'shared', 'link-local',
or 'disabled' methods as there is no usptream network.  In all other
methods, these DNS servers are used as the only DNS servers for this
connection.</doc>
        <type/>
      </property>
      <property name="dns-search"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">List of DNS search domains.  For the 'auto' method, these search domains
are appended to those returned by automatic configuration. Search domains
cannot be used with the 'shared', 'link-local', or 'disabled' methods as
there is no upstream network.  In all other methods, these search domains
are used as the only search domains for this connection.</doc>
        <type/>
      </property>
      <property name="ignore-auto-dns"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When the method is set to 'auto' and this property to TRUE, automatically
configured nameservers and search domains are ignored and only nameservers
and search domains specified in #NMSettingIP4Config:dns and
#NMSettingIP4Config:dns-search, if any, are used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="ignore-auto-routes"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When the method is set to 'auto' and this property to TRUE, automatically
configured routes are ignored and only routes specified in
#NMSettingIP4Config:routes, if any, are used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="may-fail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, allow overall network configuration to proceed even if IPv4
configuration times out.  Note that at least one IP configuration
must succeed or overall network configuration will still fail.  For
example, in IPv6-only networks, setting this property to TRUE allows
the overall network configuration to succeed if IPv4 configuration fails
but IPv6 configuration completes successfully.</doc>
        <type name="gboolean"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">IPv4 configuration method.  If 'auto' is specified then the appropriate
automatic method (DHCP, PPP, etc) is used for the interface and most
other properties can be left unset.  If 'link-local' is specified, then a
link-local address in the 169.254/16 range will be assigned to the
interface.  If 'manual' is specified, static IP addressing is used and at
least one IP address must be given in the 'addresses' property.  If
'shared' is specified (indicating that this connection will provide
network access to other computers) then the interface is assigned an
address in the 10.42.x.1/24 range and a DHCP and forwarding DNS server
are started, and the interface is NAT-ed to the current default network
connection.  'disabled' means IPv4 will not be used on this connection.
This property must be set.</doc>
        <type name="utf8"/>
      </property>
      <property name="never-default"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, this connection will never be the default IPv4 connection,
meaning it will never be assigned the default route by NetworkManager.</doc>
        <type name="gboolean"/>
      </property>
      <property name="routes"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Array of IPv4 route structures.  Each IPv4 route structure is composed
of 4 32-bit values; the first being the destination IPv4 network or
address (network byte order), the second the destination network or
address prefix (1 - 32), the third being the next-hop (network byte
order) if any, and the fourth being the route metric. For the 'auto'
method, given IP routes are appended to those returned by automatic
configuration.  Routes cannot be used with the 'shared', 'link-local',
or 'disabled' methods because there is no upstream network.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingIP4ConfigClass"
            c:type="NMSettingIP4ConfigClass"
            glib:is-gtype-struct-for="SettingIP4Config">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingIP4ConfigError"
                 glib:type-name="NMSettingIP4ConfigError"
                 glib:get-type="nm_setting_ip4_config_error_get_type"
                 c:type="NMSettingIP4ConfigError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="NotAllowedForMethod"
              value="3"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD"
              glib:nick="NotAllowedForMethod"/>
      <function name="quark" c:identifier="nm_setting_ip4_config_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingIP4Config if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingIP4Config errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingIP6Config"
           c:symbol-prefix="setting_ip6_config"
           c:type="NMSettingIP6Config"
           parent="Setting"
           glib:type-name="NMSettingIP6Config"
           glib:get-type="nm_setting_ip6_config_get_type"
           glib:type-struct="SettingIP6ConfigClass">
      <constructor name="new" c:identifier="nm_setting_ip6_config_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingIP6Config object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingIP6Config object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_address"
              c:identifier="nm_setting_ip6_config_add_address">
        <doc xml:whitespace="preserve">Adds a new IPv6 address and associated information to the setting.  The
given address is duplicated internally and is not changed by this function.

known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the address was added; %FALSE if the address was already</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new address to add</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns" c:identifier="nm_setting_ip6_config_add_dns">
        <doc xml:whitespace="preserve">Adds a new DNS server to the setting.

known</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the DNS server was added; %FALSE if the server was already</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dns" transfer-ownership="none">
            <doc xml:whitespace="preserve">the IPv6 address of the DNS server to add</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns_search"
              c:identifier="nm_setting_ip6_config_add_dns_search">
        <doc xml:whitespace="preserve">Adds a new DNS search domain to the setting.

domain was already known</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the DNS search domain was added; %FALSE if the search</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:whitespace="preserve">the search domain to add</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_route" c:identifier="nm_setting_ip6_config_add_route">
        <doc xml:whitespace="preserve">Adds a new IPv6 route and associated information to the setting.  The
given route is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the route was added; %FALSE if the route was already known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="route" transfer-ownership="none">
            <doc xml:whitespace="preserve">the route to add</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_addresses"
              c:identifier="nm_setting_ip6_config_clear_addresses">
        <doc xml:whitespace="preserve">Removes all configured addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_dns" c:identifier="nm_setting_ip6_config_clear_dns">
        <doc xml:whitespace="preserve">Removes all configured DNS servers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_dns_searches"
              c:identifier="nm_setting_ip6_config_clear_dns_searches">
        <doc xml:whitespace="preserve">Removes all configured DNS search domains.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_routes"
              c:identifier="nm_setting_ip6_config_clear_routes">
        <doc xml:whitespace="preserve">Removes all configured routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_address"
              c:identifier="nm_setting_ip6_config_get_address">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the address at index @i</doc>
          <type name="IP6Address" c:type="NMIP6Address*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the address to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns" c:identifier="nm_setting_ip6_config_get_dns">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPv6 address of the DNS server at index @i</doc>
          <type name="gpointer" c:type="gpointer*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS server to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns_search"
              c:identifier="nm_setting_ip6_config_get_dns_search">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the DNS search domain at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS search domain to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_dns"
              c:identifier="nm_setting_ip6_config_get_ignore_auto_dns">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP6Config:ignore-auto-dns
property.

advertisements) DNS information should be ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if automatically configured (ie via DHCP or router</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_ignore_auto_routes"
              c:identifier="nm_setting_ip6_config_get_ignore_auto_routes">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP6Config:ignore-auto-routes
property.

ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if automatically configured (ie via DHCP) routes should be</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_ip6_privacy"
              c:identifier="nm_setting_ip6_config_get_ip6_privacy">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP6Config:ip6-privacy
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">IPv6 Privacy Extensions configuration value (#NMSettingIP6ConfigPrivacy).</doc>
          <type name="SettingIP6ConfigPrivacy"
                c:type="NMSettingIP6ConfigPrivacy"/>
        </return-value>
      </method>
      <method name="get_may_fail"
              c:identifier="nm_setting_ip6_config_get_may_fail">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP6Config:may-fail
property.

for the connection to succeed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection doesn't require IPv6 addressing to complete</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_method"
              c:identifier="nm_setting_ip6_config_get_method">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingIP6Config:method property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_never_default"
              c:identifier="nm_setting_ip6_config_get_never_default">
        <doc xml:whitespace="preserve">Returns the value contained in the #NMSettingIP6Config:never-default
property.

for IPv6 addressing</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection should never be the default connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_num_addresses"
              c:identifier="nm_setting_ip6_config_get_num_addresses">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_dns"
              c:identifier="nm_setting_ip6_config_get_num_dns">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured DNS servers</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_dns_searches"
              c:identifier="nm_setting_ip6_config_get_num_dns_searches">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured DNS search domains</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_routes"
              c:identifier="nm_setting_ip6_config_get_num_routes">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of configured routes</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_route" c:identifier="nm_setting_ip6_config_get_route">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the route at index @i</doc>
          <type name="IP6Route" c:type="NMIP6Route*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the route to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_address"
              c:identifier="nm_setting_ip6_config_remove_address">
        <doc xml:whitespace="preserve">Removes the address at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the address to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns"
              c:identifier="nm_setting_ip6_config_remove_dns">
        <doc xml:whitespace="preserve">Removes the DNS server at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS server to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search"
              c:identifier="nm_setting_ip6_config_remove_dns_search">
        <doc xml:whitespace="preserve">Removes the DNS search domain at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the DNS search domain</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route"
              c:identifier="nm_setting_ip6_config_remove_route">
        <doc xml:whitespace="preserve">Removes the route at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index number of the route</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <property name="addresses"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Array of IPv6 address structures.  Each IPv6 address structure is
composed of 3 members, the first being a byte array containing the IPv6
address (network byte order), the second a 32-bit integer containing the
IPv6 address prefix, and the third a byte array containing the IPv6
address (network byte order) of the gateway associated with this address,
if any.  If no gateway is given, the third element should be given as
all zeros.  For the 'auto' method, given IP addresses are appended to
those returned by automatic configuration.  Addresses cannot be used with
the 'shared' or 'link-local' methods as the interface is automatically
assigned an address with these methods.</doc>
        <type/>
      </property>
      <property name="dns"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Array of DNS servers, where each member of the array is a byte array
containing the IPv6 address of the DNS server (in network byte order).
For the 'auto' method, these DNS servers are appended to those (if any)
returned by automatic configuration.  DNS servers cannot be used with
the 'shared' or 'link-local' methods as there is no usptream network. In
all other methods, these DNS servers are used as the only DNS servers for
this connection.</doc>
        <type/>
      </property>
      <property name="dns-search"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">List of DNS search domains.  For the 'auto' method, these search domains
are appended to those returned by automatic configuration. Search domains
cannot be used with the 'shared' or 'link-local' methods as there is no
upstream network.  In all other methods, these search domains are used
as the only search domains for this connection.</doc>
        <type/>
      </property>
      <property name="ignore-auto-dns"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When the method is set to 'auto' or 'dhcp' and this property is set to
TRUE, automatically configured nameservers and search domains are ignored
and only nameservers and search domains specified in
#NMSettingIP6Config:dns and #NMSettingIP6Config:dns-search, if any, are
used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="ignore-auto-routes"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When the method is set to 'auto' or 'dhcp' and this property is set to
TRUE, automatically configured routes are ignored and only routes
specified in #NMSettingIP6Config:routes, if any, are used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="ip6-privacy"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Configure IPv6 Privacy Extensions for SLAAC, described in RFC4941.
If enabled, it makes the kernel generate a temporary IPv6 address
in addition to the public one generated from MAC address via
modified EUI-64.  This enhances privacy, but could cause problems
in some applications, on the other hand.  The permitted values
are: 0: disabled, 1: enabled (prefer public address),
2: enabled (prefer temporary addresses).</doc>
        <type name="gint"/>
      </property>
      <property name="may-fail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, allow overall network configuration to proceed even if IPv6
configuration times out.  Note that at least one IP configuration
must succeed or overall network configuration will still fail.  For
example, in IPv4-only networks, setting this property to TRUE allows
the overall network configuration to succeed if IPv6 configuration fails
but IPv4 configuration completes successfully.</doc>
        <type name="gboolean"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">IPv6 configuration method.  If 'auto' is specified then the appropriate
automatic method (DHCP, PPP, advertisement, etc) is used for the
interface and most other properties can be left unset.  To force the use
of DHCP only, specify 'dhcp'; this  method is only valid for ethernet-
based hardware.  If 'link-local' is specified, then an IPv6 link-local
address will be assigned to the interface.  If 'manual' is specified,
static IP addressing is used and at least one IP address must be given
in the 'addresses' property.  If 'ignored' is specified, IPv6
configuration is not done. This property must be set.  NOTE: the 'shared'
method are not yet supported.</doc>
        <type name="utf8"/>
      </property>
      <property name="never-default"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, this connection will never be the default IPv6 connection,
meaning it will never be assigned the default IPv6 route by NetworkManager.</doc>
        <type name="gboolean"/>
      </property>
      <property name="routes"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Array of IPv6 route structures.  Each IPv6 route structure is composed
of 4 members; the first being the destination IPv6 network or
address (network byte order) as a byte array, the second the destination
network or address IPv6 prefix, the third being the next-hop IPv6 address
(network byte order) if any, and the fourth being the route metric. For
the 'auto' method, given IP routes are appended to those returned by
automatic configuration.  Routes cannot be used with the 'shared' or
'link-local' methods because there is no upstream network.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingIP6ConfigClass"
            c:type="NMSettingIP6ConfigClass"
            glib:is-gtype-struct-for="SettingIP6Config">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingIP6ConfigError"
                 glib:type-name="NMSettingIP6ConfigError"
                 glib:get-type="nm_setting_ip6_config_error_get_type"
                 c:type="NMSettingIP6ConfigError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="NotAllowedForMethod"
              value="3"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD"
              glib:nick="NotAllowedForMethod"/>
      <function name="quark" c:identifier="nm_setting_ip6_config_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingIP6Config if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingIP6Config errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingIP6ConfigPrivacy"
                 glib:type-name="NMSettingIP6ConfigPrivacy"
                 glib:get-type="nm_setting_ip6_config_privacy_get_type"
                 c:type="NMSettingIP6ConfigPrivacy">
      <doc xml:whitespace="preserve">#NMSettingIP6ConfigPrivacy values indicate if and how IPv6 Privacy
Extensions are used (RFC4941).</doc>
      <member name="unknown"
              value="-1"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN"
              glib:nick="unknown"/>
      <member name="disabled"
              value="0"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED"
              glib:nick="disabled"/>
      <member name="prefer_public_addr"
              value="1"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR"
              glib:nick="prefer-public-addr"/>
      <member name="prefer_temp_addr"
              value="2"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR"
              glib:nick="prefer-temp-addr"/>
    </enumeration>
    <class name="SettingInfiniband"
           c:symbol-prefix="setting_infiniband"
           c:type="NMSettingInfiniband"
           parent="Setting"
           glib:type-name="NMSettingInfiniband"
           glib:get-type="nm_setting_infiniband_get_type"
           glib:type-struct="SettingInfinibandClass">
      <constructor name="new" c:identifier="nm_setting_infiniband_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingInfiniband object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingInfiniband object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mac_address"
              c:identifier="nm_setting_infiniband_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingInfiniband:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_infiniband_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingInfiniband:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_transport_mode"
              c:identifier="nm_setting_infiniband_get_transport_mode">
        <doc xml:whitespace="preserve">Returns the transport mode for this device. Either 'datagram' or
'connected'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IPoIB transport mode</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, this connection will only apply to the IPoIB
device whose permanent MAC address matches. This property does
not change the MAC address of the device (i.e. MAC spoofing).</doc>
        <type/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple frames.</doc>
        <type name="guint"/>
      </property>
      <property name="transport-mode"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The IP-over-InfiniBand transport mode. Either 'datagram' or
'connected'.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingInfinibandClass"
            c:type="NMSettingInfinibandClass"
            glib:is-gtype-struct-for="SettingInfiniband">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingInfinibandError"
                 glib:type-name="NMSettingInfinibandError"
                 glib:get-type="nm_setting_infiniband_error_get_type"
                 c:type="NMSettingInfinibandError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_INFINIBAND_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_INFINIBAND_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_INFINIBAND_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_infiniband_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingInfiniband if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingInfiniband errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingOlpcMesh"
           c:symbol-prefix="setting_olpc_mesh"
           c:type="NMSettingOlpcMesh"
           parent="Setting"
           glib:type-name="NMSettingOlpcMesh"
           glib:get-type="nm_setting_olpc_mesh_get_type"
           glib:type-struct="SettingOlpcMeshClass">
      <constructor name="new" c:identifier="nm_setting_olpc_mesh_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingOlpcMesh object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingOlpcMesh object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_channel"
              c:identifier="nm_setting_olpc_mesh_get_channel">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_dhcp_anycast_address"
              c:identifier="nm_setting_olpc_mesh_get_dhcp_anycast_address">
        <return-value transfer-ownership="none">
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_ssid" c:identifier="nm_setting_olpc_mesh_get_ssid">
        <return-value transfer-ownership="none">
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <property name="channel"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Channel on which the mesh network to join is located.</doc>
        <type name="guint"/>
      </property>
      <property name="dhcp-anycast-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Anycast DHCP address used when requesting an IP address via DHCP.  The
specific anycast address used determines which DHCP server class answers
the request.</doc>
        <type/>
      </property>
      <property name="ssid"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">SSID of the mesh network to join.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingOlpcMeshClass"
            c:type="NMSettingOlpcMeshClass"
            glib:is-gtype-struct-for="SettingOlpcMesh">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingOlpcMeshError"
                 glib:type-name="NMSettingOlpcMeshError"
                 glib:get-type="nm_setting_olpc_mesh_error_get_type"
                 c:type="NMSettingOlpcMeshError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_OLPC_MESH_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_OLPC_MESH_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_OLPC_MESH_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_olpc_mesh_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingPPP"
           c:symbol-prefix="setting_ppp"
           c:type="NMSettingPPP"
           parent="Setting"
           glib:type-name="NMSettingPPP"
           glib:get-type="nm_setting_ppp_get_type"
           glib:type-struct="SettingPPPClass">
      <constructor name="new" c:identifier="nm_setting_ppp_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingPPP object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingPPP object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_baud" c:identifier="nm_setting_ppp_get_baud">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_crtscts" c:identifier="nm_setting_ppp_get_crtscts">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_lcp_echo_failure"
              c:identifier="nm_setting_ppp_get_lcp_echo_failure">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_lcp_echo_interval"
              c:identifier="nm_setting_ppp_get_lcp_echo_interval">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_mppe_stateful"
              c:identifier="nm_setting_ppp_get_mppe_stateful">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_mru" c:identifier="nm_setting_ppp_get_mru">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_ppp_get_mtu">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_no_vj_comp"
              c:identifier="nm_setting_ppp_get_no_vj_comp">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_noauth" c:identifier="nm_setting_ppp_get_noauth">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_nobsdcomp" c:identifier="nm_setting_ppp_get_nobsdcomp">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_nodeflate" c:identifier="nm_setting_ppp_get_nodeflate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_refuse_chap"
              c:identifier="nm_setting_ppp_get_refuse_chap">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_refuse_eap"
              c:identifier="nm_setting_ppp_get_refuse_eap">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_refuse_mschap"
              c:identifier="nm_setting_ppp_get_refuse_mschap">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_refuse_mschapv2"
              c:identifier="nm_setting_ppp_get_refuse_mschapv2">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_refuse_pap"
              c:identifier="nm_setting_ppp_get_refuse_pap">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_require_mppe"
              c:identifier="nm_setting_ppp_get_require_mppe">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_require_mppe_128"
              c:identifier="nm_setting_ppp_get_require_mppe_128">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="baud"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, instruct pppd to set the serial port to the specified
baudrate.  This value should normally be left as 0 to automatically
choose the speed.</doc>
        <type name="guint"/>
      </property>
      <property name="crtscts"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, specify that pppd should set the serial port to use hardware
flow control with RTS and CTS signals.  This value should normally be
set to FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="lcp-echo-failure"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, instruct pppd to presume the connection to the peer has
failed if the specified number of LCP echo-requests go unanswered by the
peer.  The 'lcp-echo-interval' property must also be set to a non-zero
value if this property is used.</doc>
        <type name="guint"/>
      </property>
      <property name="lcp-echo-interval"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, instruct pppd to send an LCP echo-request frame to the peer
every n seconds (where n is the specified value).  Note that some PPP
peers will respond to echo requests and some will not, and it is not
possible to autodetect this.</doc>
        <type name="guint"/>
      </property>
      <property name="mppe-stateful"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, stateful MPPE is used.  See pppd documentation for more
information on stateful MPPE.",</doc>
        <type name="gboolean"/>
      </property>
      <property name="mru"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, instruct pppd to request that the peer send packets no
larger than the specified size.  If non-zero, the MRU should be between
128 and 16384.</doc>
        <type name="guint"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, instruct pppd to send packets no larger than the specified
size.</doc>
        <type name="guint"/>
      </property>
      <property name="no-vj-comp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, Van Jacobsen TCP header compression will not be requested.</doc>
        <type name="gboolean"/>
      </property>
      <property name="noauth"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, do not require the other side (usually the PPP server) to
authenticate itself to the client.  If FALSE, require authentication from
the remote side.  In almost all cases, this should be TRUE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="nobsdcomp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, BSD compression will not be requested.</doc>
        <type name="gboolean"/>
      </property>
      <property name="nodeflate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, 'deflate' compression will not be requested.</doc>
        <type name="gboolean"/>
      </property>
      <property name="refuse-chap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, the CHAP authentication method will not be used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="refuse-eap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, the EAP authentication method will not be used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="refuse-mschap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, the MSCHAP authentication method will not be used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="refuse-mschapv2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, the MSCHAPv2 authentication method will not be used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="refuse-pap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, the PAP authentication method will not be used.</doc>
        <type name="gboolean"/>
      </property>
      <property name="require-mppe"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, MPPE (Microsoft Point-to-Point Encrpytion) will be required for
the PPP session.  If either 64-bit or 128-bit MPPE is not available the
session will fail.  Note that MPPE is not used on mobile broadband
connections.</doc>
        <type name="gboolean"/>
      </property>
      <property name="require-mppe-128"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, 128-bit MPPE (Microsoft Point-to-Point Encrpytion) will be
required for the PPP session, and the 'require-mppe' property must also
be set to TRUE.  If 128-bit MPPE is not available the session will fail.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingPPPClass"
            c:type="NMSettingPPPClass"
            glib:is-gtype-struct-for="SettingPPP">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingPPPError"
                 glib:type-name="NMSettingPPPError"
                 glib:get-type="nm_setting_ppp_error_get_type"
                 c:type="NMSettingPPPError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_PPP_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_PPP_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_PPP_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="RequireMPPENotAllowed"
              value="3"
              c:identifier="NM_SETTING_PPP_ERROR_REQUIRE_MPPE_NOT_ALLOWED"
              glib:nick="RequireMPPENotAllowed"/>
      <function name="quark" c:identifier="nm_setting_ppp_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingPPP if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingPPP errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingPPPOE"
           c:symbol-prefix="setting_pppoe"
           c:type="NMSettingPPPOE"
           parent="Setting"
           glib:type-name="NMSettingPPPOE"
           glib:get-type="nm_setting_pppoe_get_type"
           glib:type-struct="SettingPPPOEClass">
      <constructor name="new" c:identifier="nm_setting_pppoe_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingPPPOE object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingPPPOE object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_password" c:identifier="nm_setting_pppoe_get_password">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_pppoe_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingPPPOE:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_service" c:identifier="nm_setting_pppoe_get_service">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingPPPOE:password property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_username" c:identifier="nm_setting_pppoe_get_username">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Password used to authenticate with the PPPoE service.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingPPPOE:password:.</doc>
        <type name="guint"/>
      </property>
      <property name="service" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, instruct PPPoE to only initiate sessions with access
concentrators that provide the specified serivce.  For most providers,
this should be left blank.  It is only required if there are multiple
access concentrators or a specific service is known to be required.</doc>
        <type name="utf8"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Username used to authenticate with the PPPoE service.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingPPPOEClass"
            c:type="NMSettingPPPOEClass"
            glib:is-gtype-struct-for="SettingPPPOE">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingPPPOEError"
                 glib:type-name="NMSettingPPPOEError"
                 glib:get-type="nm_setting_pppoe_error_get_type"
                 c:type="NMSettingPPPOEError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_PPPOE_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_PPPOE_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_PPPOE_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="MissingPPPSetting"
              value="3"
              c:identifier="NM_SETTING_PPPOE_ERROR_MISSING_PPP_SETTING"
              glib:nick="MissingPPPSetting"/>
      <function name="quark" c:identifier="nm_setting_pppoe_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingPPPOE if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingPPPOE errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingSecretFlags"
                 glib:type-name="NMSettingSecretFlags"
                 glib:get-type="nm_setting_secret_flags_get_type"
                 c:type="NMSettingSecretFlags">
      <doc xml:whitespace="preserve">These flags indicate specific behavior related to handling of a secret.  Each
secret has a corresponding set of these flags which indicate how the secret
is to be stored and/or requested when it is needed.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_SECRET_FLAG_NONE"
              glib:nick="none"/>
      <member name="agent_owned"
              value="1"
              c:identifier="NM_SETTING_SECRET_FLAG_AGENT_OWNED"
              glib:nick="agent-owned"/>
      <member name="not_saved"
              value="2"
              c:identifier="NM_SETTING_SECRET_FLAG_NOT_SAVED"
              glib:nick="not-saved"/>
      <member name="not_required"
              value="4"
              c:identifier="NM_SETTING_SECRET_FLAG_NOT_REQUIRED"
              glib:nick="not-required"/>
    </enumeration>
    <class name="SettingSerial"
           c:symbol-prefix="setting_serial"
           c:type="NMSettingSerial"
           parent="Setting"
           glib:type-name="NMSettingSerial"
           glib:get-type="nm_setting_serial_get_type"
           glib:type-struct="SettingSerialClass">
      <constructor name="new" c:identifier="nm_setting_serial_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingSerial object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingSerial object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_baud" c:identifier="nm_setting_serial_get_baud">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSerial:baud property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_bits" c:identifier="nm_setting_serial_get_bits">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSerial:bits property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_parity" c:identifier="nm_setting_serial_get_parity">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSerial:parity property of the setting</doc>
          <type name="gchar" c:type="char"/>
        </return-value>
      </method>
      <method name="get_send_delay"
              c:identifier="nm_setting_serial_get_send_delay">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSerial:send-delay property of the setting</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_stopbits"
              c:identifier="nm_setting_serial_get_stopbits">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSerial:stopbits property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <property name="baud"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Speed to use for communication over the serial port.  Note that this value
usually has no effect for mobile broadband modems as they generally
ignore speed settings and use the highest available speed.</doc>
        <type name="guint"/>
      </property>
      <property name="bits"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Byte-width of the serial communication.</doc>
        <type name="guint"/>
      </property>
      <property name="parity"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Parity setting of the serial port.  Either 'E' for even parity, 'o' for
odd parity, or 'n' for no parity.</doc>
        <type name="gchar"/>
      </property>
      <property name="send-delay"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Time to delay between each byte sent to the modem, in microseconds.</doc>
        <type name="guint64"/>
      </property>
      <property name="stopbits"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Number of stop bits for communication on the serial port.  Either 1 or 2.
The 1 in '8n1' for example.</doc>
        <type name="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingSerialClass"
            c:type="NMSettingSerialClass"
            glib:is-gtype-struct-for="SettingSerial">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingSerialError"
                 glib:type-name="NMSettingSerialError"
                 glib:get-type="nm_setting_serial_error_get_type"
                 c:type="NMSettingSerialError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_SERIAL_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_SERIAL_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_SERIAL_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="MissingPPPSetting"
              value="3"
              c:identifier="NM_SETTING_SERIAL_ERROR_MISSING_PPP_SETTING"
              glib:nick="MissingPPPSetting"/>
      <function name="quark" c:identifier="nm_setting_serial_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingSerial if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingSerial errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingVPN"
           c:symbol-prefix="setting_vpn"
           c:type="NMSettingVPN"
           parent="Setting"
           glib:type-name="NMSettingVPN"
           glib:get-type="nm_setting_vpn_get_type"
           glib:type-struct="SettingVPNClass">
      <constructor name="new" c:identifier="nm_setting_vpn_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingVPN object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingVPN object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_data_item" c:identifier="nm_setting_vpn_add_data_item">
        <doc xml:whitespace="preserve">Establishes a relationship between @key and @item internally in the
setting which may be retrieved later.  Should not be used to store passwords
or other secrets, which is what nm_setting_vpn_add_secret() is for.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a name that uniquely identifies the given value @item</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to be referenced by @key</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_secret" c:identifier="nm_setting_vpn_add_secret">
        <doc xml:whitespace="preserve">Establishes a relationship between @key and @secret internally in the
setting which may be retrieved later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a name that uniquely identifies the given secret @secret</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="secret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the secret to be referenced by @key</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_data_item"
              c:identifier="nm_setting_vpn_foreach_data_item">
        <doc xml:whitespace="preserve">Iterates all data items stored in this setting.  It is safe to add, remove,
and modify data items inside @func, though any additions or removals made
during iteration will not be part of the iteration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">an user provided function</doc>
            <type name="VPNIterFunc" c:type="NMVPNIterFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to be passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_secret"
              c:identifier="nm_setting_vpn_foreach_secret">
        <doc xml:whitespace="preserve">Iterates all secrets stored in this setting.  It is safe to add, remove,
and modify secrets inside @func, though any additions or removals made during
iteration will not be part of the iteration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">an user provided function</doc>
            <type name="VPNIterFunc" c:type="NMVPNIterFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to be passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data_item" c:identifier="nm_setting_vpn_get_data_item">
        <doc xml:whitespace="preserve">Retrieves the data item of a key/value relationship previously established
by nm_setting_vpn_add_data_item().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the data item, if any</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the data item to retrieve</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_data_items"
              c:identifier="nm_setting_vpn_get_num_data_items">
        <doc xml:whitespace="preserve">Gets number of key/value pairs of VPN configuration data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of VPN plugin specific configuration data items</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_secrets"
              c:identifier="nm_setting_vpn_get_num_secrets">
        <doc xml:whitespace="preserve">Gets number of VPN plugin specific secrets in the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of VPN plugin specific secrets</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_secret" c:identifier="nm_setting_vpn_get_secret">
        <doc xml:whitespace="preserve">Retrieves the secret of a key/value relationship previously established
by nm_setting_vpn_add_secret().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the secret, if any</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the secret to retrieve</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service_type"
              c:identifier="nm_setting_vpn_get_service_type">
        <doc xml:whitespace="preserve">Returns the service name of the VPN, which identifies the specific VPN
plugin that should be used to connect to this VPN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the VPN plugin's service name</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_user_name" c:identifier="nm_setting_vpn_get_user_name">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingVPN:user-name property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="remove_data_item"
              c:identifier="nm_setting_vpn_remove_data_item">
        <doc xml:whitespace="preserve">Deletes a key/value relationship previously established by
nm_setting_vpn_add_data_item().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the data item to remove</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secret" c:identifier="nm_setting_vpn_remove_secret">
        <doc xml:whitespace="preserve">Deletes a key/value relationship previously established by
nm_setting_vpn_add_secret().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the secret to remove</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="data"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Dictionary of key/value pairs of VPN plugin specific data.  Both keys
and values must be strings.</doc>
        <type/>
      </property>
      <property name="secrets"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Dictionary of key/value pairs of VPN plugin specific secrets like
passwords or private keys.  Both keys and values must be strings.</doc>
        <type/>
      </property>
      <property name="service-type" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">D-Bus service name of the VPN plugin that this setting uses to connect
to its network.  i.e. org.freedesktop.NetworkManager.vpnc for the vpnc
plugin.</doc>
        <type name="utf8"/>
      </property>
      <property name="user-name" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the VPN connection requires a user name for authentication, that name
should be provided here.  If the connection is available to more than
one user, and the VPN requires each user to supply a different name, then
leave this property empty.  If this property is empty, NetworkManager
will automatically supply the username of the user which requested the
VPN connection.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVPNClass"
            c:type="NMSettingVPNClass"
            glib:is-gtype-struct-for="SettingVPN">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SettingValueIterFn" c:type="NMSettingValueIterFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setting for which properties are being iterated, given to nm_setting_enumerate_values()</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The value/property name</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The property's value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">The property's flags, like %NM_SETTING_PARAM_SECRET</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:whitespace="preserve">User data passed to nm_setting_enumerate_values()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SettingVlan"
           c:symbol-prefix="setting_vlan"
           c:type="NMSettingVlan"
           parent="Setting"
           glib:type-name="NMSettingVlan"
           glib:get-type="nm_setting_vlan_get_type"
           glib:type-struct="SettingVlanClass">
      <constructor name="new" c:identifier="nm_setting_vlan_new">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingVlan object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_priority" c:identifier="nm_setting_vlan_add_priority">
        <doc xml:whitespace="preserve">Adds a priority mapping to the #NMSettingVlan:ingress_priority_map or
#NMSettingVlan:egress_priority_map properties of the setting. If @from is
already in the given priority map, this function will overwrite the
existing entry with the new @to.

If @map is #NM_VLAN_INGRESS_MAP then @from is the incoming 802.1q VLAN
Priority Code Point (PCP) value, and @to is the Linux SKB priority value.

If @map is #NM_VLAN_EGRESS_MAP then @from is the Linux SKB priority value and
@to is the outgoing 802.1q VLAN Priority Code Point (PCP) value.

list, FALSE if error</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the new priority mapping was successfully added to the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="map" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:whitespace="preserve">the priority to map to @to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:whitespace="preserve">the priority to map @from to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_priority_str"
              c:identifier="nm_setting_vlan_add_priority_str">
        <doc xml:whitespace="preserve">Adds a priority map entry into either the #NMSettingVlan:ingress_priority_map
or the #NMSettingVlan:egress_priority_map properties.  The priority map maps
the Linux SKB priorities to 802.1p priorities.

overwrote the old value, FALSE if error</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the entry was successfully added to the list, or it</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="map" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:whitespace="preserve">the string which contains a priority map, like "3:7"</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_priorities"
              c:identifier="nm_setting_vlan_clear_priorities">
        <doc xml:whitespace="preserve">Clear all the entires from #NMSettingVlan:ingress_priority_map or
#NMSettingVlan:egress_priority_map properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="map" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="nm_setting_vlan_get_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingVlan:flags property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_id" c:identifier="nm_setting_vlan_get_id">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingVlan:id property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_vlan_get_interface_name">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingVlan:interface_name property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_num_priorities"
              c:identifier="nm_setting_vlan_get_num_priorities">
        <doc xml:whitespace="preserve">Returns the number of entires in the
#NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
properties of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">return the number of ingress/egress priority entries, -1 if error</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <parameter name="map" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="nm_setting_vlan_get_parent">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingVlan:parent property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_priority" c:identifier="nm_setting_vlan_get_priority">
        <doc xml:whitespace="preserve">Retrieve one of the entries of the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map properties of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a priority map was returned, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="map" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the zero-based index of the ingress/egress priority map entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_from"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">on return the value of the priority map's 'from' item</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="out_to"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">on return the value of priority map's 'to' item</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority"
              c:identifier="nm_setting_vlan_remove_priority">
        <doc xml:whitespace="preserve">Removes the priority map at index @idx from the
#NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="map" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the zero-based index of the priority map to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <property name="egress-priority-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">For outgoing packets, a list of mappings from Linux SKB priorities to
802.1p priorities.  The mapping is given in the format 'from:to'
where both 'from' and 'to' are unsigned integers, ie '7:3'.</doc>
        <type/>
      </property>
      <property name="flags"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">One or more of %NMVlanFlags which control the behavior and features of
the VLAN interface.</doc>
        <type name="guint"/>
      </property>
      <property name="id" writable="1" construct="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The VLAN identifier the interface created by this connection should be
assigned.</doc>
        <type name="guint"/>
      </property>
      <property name="ingress-priority-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">For incoming packets, a list of mappings from 802.1p priorities to Linux
SKB priorities.  The mapping is given in the format 'from:to' where both
'from' and 'to' are unsigned integers, ie '7:3'.</doc>
        <type/>
      </property>
      <property name="interface-name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If given, specifies the kernel name of the VLAN interface. If not given,
a default name will be constructed from the interface described by the
parent interface and the #NMSettingVlan:id , ex 'eth2.1'. The parent
interface may be given by the #NMSettingVlan:parent property or by a
hardware address property, eg #NMSettingWired:mac-address or
#NMSettingInfiniband:mac-address.</doc>
        <type name="utf8"/>
      </property>
      <property name="parent"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If given, specifies the parent interface name or parent connection UUID
from which this VLAN interface should be created.  If this property is
not specified, the connection must contain a hardware address in a
hardware-specific setting, like #NMSettingWired:mac-address or
#NMSettingInfiniband:mac-address.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVlanClass"
            c:type="NMSettingVlanClass"
            glib:is-gtype-struct-for="SettingVlan">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingVlanError"
                 glib:type-name="NMSettingVlanError"
                 glib:get-type="nm_setting_vlan_error_get_type"
                 c:type="NMSettingVlanError">
      <member name="Unknown"
              value="0"
              c:identifier="NM_SETTING_VLAN_ERROR_UNKNOWN"
              glib:nick="Unknown"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_VLAN_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_VLAN_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_vlan_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingVlan if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingVlan errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingVpnError"
                 glib:type-name="NMSettingVpnError"
                 glib:get-type="nm_setting_vpn_error_get_type"
                 c:type="NMSettingVpnError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_VPN_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_VPN_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_VPN_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_vpn_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingVPN if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingVPN errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWimax"
           c:symbol-prefix="setting_wimax"
           c:type="NMSettingWimax"
           parent="Setting"
           glib:type-name="NMSettingWimax"
           glib:get-type="nm_setting_wimax_get_type"
           glib:type-struct="SettingWimaxClass">
      <constructor name="new" c:identifier="nm_setting_wimax_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingWimax object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingWimax object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mac_address"
              c:identifier="nm_setting_wimax_get_mac_address">
        <doc xml:whitespace="preserve">Returns the MAC address of a WiMAX device which this connection is locked
to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the MAC address</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_network_name"
              c:identifier="nm_setting_wimax_get_network_name">
        <doc xml:whitespace="preserve">Returns the WiMAX NSP name (ex "Sprint" or "CLEAR") which identifies the
specific WiMAX network this setting describes a connection to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the WiMAX NSP name</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, this connection will only apply to the WiMAX device
whose MAC address matches. This property does not change the MAC address
of the device (known as MAC spoofing).</doc>
        <type/>
      </property>
      <property name="network-name" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Network Service Provider (NSP) name of the WiMAX network this connection
should use.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWimaxClass"
            c:type="NMSettingWimaxClass"
            glib:is-gtype-struct-for="SettingWimax">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
    </record>
    <enumeration name="SettingWimaxError"
                 glib:type-name="NMSettingWimaxError"
                 glib:get-type="nm_setting_wimax_error_get_type"
                 c:type="NMSettingWimaxError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIMAX_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIMAX_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIMAX_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_wimax_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingWimax if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingWimax errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWired"
           c:symbol-prefix="setting_wired"
           c:type="NMSettingWired"
           parent="Setting"
           glib:type-name="NMSettingWired"
           glib:get-type="nm_setting_wired_get_type"
           glib:type-struct="SettingWiredClass">
      <constructor name="new" c:identifier="nm_setting_wired_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingWired object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingWired object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_s390_option"
              c:identifier="nm_setting_wired_add_s390_option">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_auto_negotiate"
              c:identifier="nm_setting_wired_get_auto_negotiate">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:auto-negotiate property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_cloned_mac_address"
              c:identifier="nm_setting_wired_get_cloned_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:cloned-mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_duplex" c:identifier="nm_setting_wired_get_duplex">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:duplex property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_wired_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_mac_address_blacklist"
              c:identifier="nm_setting_wired_get_mac_address_blacklist">
        <doc xml:whitespace="preserve">property of the setting</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:mac-address-blacklist</doc>
          <type name="GLib.SList" c:type="GSList*">
            <array name="GLib.ByteArray">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </type>
        </return-value>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_wired_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_s390_options"
              c:identifier="nm_setting_wired_get_num_s390_options">
        <doc xml:whitespace="preserve">Returns the number of s390-specific options that should be set for this
device when it is activated.  This can be used to retrieve each s390
option individually using nm_setting_wired_get_s390_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of s390-specific device options</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_port" c:identifier="nm_setting_wired_get_port">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:port property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_s390_nettype"
              c:identifier="nm_setting_wired_get_s390_nettype">
        <doc xml:whitespace="preserve">Returns the s390 device type this connection should apply to.  Will be one
of 'qeth', 'lcs', or 'ctc'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the s390 device type</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_s390_option"
              c:identifier="nm_setting_wired_get_s390_option">
        <doc xml:whitespace="preserve">Given an index, return the value of the s390 option at that index.  indexes
are *not* guaranteed to be static across modifications to options done by
nm_setting_wired_add_s390_option() and nm_setting_wired_remove_s390_option(),
and should not be used to refer to options except for short periods of time
such as during option iteration.

%FALSE if the index was invalid (ie, greater than the number of options
currently held by the setting)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success if the index was valid and an option was found,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of the desired option, from 0 to nm_setting_wired_get_num_s390_options() - 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_key"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">on return, the key name of the s390 specific option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">on return, the value of the key of the s390 specific option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_s390_option_by_key"
              c:identifier="nm_setting_wired_get_s390_option_by_key">
        <doc xml:whitespace="preserve">Returns the value associated with the s390-specific option specified by
@key, if it exists.

setting; the value is owned by the setting and must not be modified</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value, or NULL if the key/value pair was never added to the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key for which to retrieve the value</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_s390_subchannels"
              c:identifier="nm_setting_wired_get_s390_subchannels">
        <doc xml:whitespace="preserve">Return the list of s390 subchannels that identify the device that this
connection is applicable to.  The connection should only be used in
conjunction with that device.

subchannel the s390 device uses to communicate to the host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GPtrArray of strings, each specifying one</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_speed" c:identifier="nm_setting_wired_get_speed">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWired:speed property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="remove_s390_option"
              c:identifier="nm_setting_wired_remove_s390_option">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-negotiate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="cloned-mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, request that the device use this MAC address instead of its
permanent MAC address.  This is known as MAC cloning or spoofing.</doc>
        <type/>
      </property>
      <property name="duplex" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, request that the device only use the specified duplex mode.
Either 'half' or 'full'.</doc>
        <type name="utf8"/>
      </property>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, this connection will only apply to the ethernet device
whose permanent MAC address matches. This property does not change the MAC address
of the device (i.e. MAC spoofing).</doc>
        <type/>
      </property>
      <property name="mac-address-blacklist"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, this connection will never apply to the ethernet device
whose permanent MAC address matches an address in the list.  Each
MAC address is in the standard hex-digits-and-colons notation
(00:11:22:33:44:55).</doc>
        <type/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple Ethernet frames.</doc>
        <type name="guint"/>
      </property>
      <property name="port" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Specific port type to use if multiple the device supports multiple
attachment methods.  One of 'tp' (Twisted Pair), 'aui' (Attachment Unit
Interface), 'bnc' (Thin Ethernet) or 'mii' (Media Independent Interface.
If the device supports only one port type, this setting is ignored.</doc>
        <type name="utf8"/>
      </property>
      <property name="s390-nettype" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">s390 network device type; one of 'qeth', 'lcs', or 'ctc', representing
the different types of virtual network devices available on s390 systems.</doc>
        <type name="utf8"/>
      </property>
      <property name="s390-options"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Dictionary of key/value pairs of s390-specific device options.  Both keys
and values must be strings.  Allowed keys include 'portno', 'layer2',
'portname', 'protocol', among others.  Key names must contain only
alphanumeric characters (ie, [a-zA-Z0-9]).</doc>
        <type/>
      </property>
      <property name="s390-subchannels"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Identifies specific subchannels that this network device uses for
communcation with z/VM or s390 host.  Like #NMSettingWired:mac-address
for non-z/VM devices, this property can be used to ensure this connection
only applies to the network device that uses these subchannels.  The
list should contain exactly 3 strings, and each string may only be
composed of hexadecimal characters and the period (.) character.</doc>
        <type/>
      </property>
      <property name="speed"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, request that the device use only the specified speed. 
In Mbit/s, ie 100 == 100Mbit/s.</doc>
        <type name="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWiredClass"
            c:type="NMSettingWiredClass"
            glib:is-gtype-struct-for="SettingWired">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingWiredError"
                 glib:type-name="NMSettingWiredError"
                 glib:get-type="nm_setting_wired_error_get_type"
                 c:type="NMSettingWiredError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIRED_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIRED_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIRED_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <function name="quark" c:identifier="nm_setting_wired_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingWired if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingWired errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWireless"
           c:symbol-prefix="setting_wireless"
           c:type="NMSettingWireless"
           parent="Setting"
           glib:type-name="NMSettingWireless"
           glib:get-type="nm_setting_wireless_get_type"
           glib:type-struct="SettingWirelessClass">
      <constructor name="new" c:identifier="nm_setting_wireless_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingWireless object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingWireless object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_seen_bssid"
              c:identifier="nm_setting_wireless_add_seen_bssid">
        <doc xml:whitespace="preserve">Adds a new WiFi AP's BSSID to the previously seen BSSID list of the setting.
NetworkManager tracks previously seen BSSIDs internally so this function
no longer has much use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @bssid was already known, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="bssid" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new BSSID to add to the list</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ap_security_compatible"
              c:identifier="nm_setting_wireless_ap_security_compatible">
        <doc xml:whitespace="preserve">Given a #NMSettingWireless and an optional #NMSettingWirelessSecurity,
determine if the configuration given by the settings is compatible with
the security of an access point using that access point's capability flags
and mode.  Useful for clients that wish to filter a set of connections
against a set of access points and determine which connections are
compatible with which access points.

security flags and mode, %FALSE if they are not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given settings are compatible with the access point's</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="s_wireless_sec" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSettingWirelessSecurity or %NULL</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </parameter>
          <parameter name="ap_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NM80211ApFlags of the given access point</doc>
            <type name="80211ApFlags" c:type="NM80211ApFlags"/>
          </parameter>
          <parameter name="ap_wpa" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NM80211ApSecurityFlags of the given access point's WPA capabilities</doc>
            <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
          </parameter>
          <parameter name="ap_rsn" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NM80211ApSecurityFlags of the given access point's WPA2/RSN capabilities</doc>
            <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
          </parameter>
          <parameter name="ap_mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the 802.11 mode of the AP, either Ad-Hoc or Infrastructure</doc>
            <type name="80211Mode" c:type="NM80211Mode"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_band" c:identifier="nm_setting_wireless_get_band">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:band property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_bssid" c:identifier="nm_setting_wireless_get_bssid">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:bssid property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_channel"
              c:identifier="nm_setting_wireless_get_channel">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:channel property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_cloned_mac_address"
              c:identifier="nm_setting_wireless_get_cloned_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:cloned-mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_wireless_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_mac_address_blacklist"
              c:identifier="nm_setting_wireless_get_mac_address_blacklist">
        <doc xml:whitespace="preserve">#NMSettingWireless:mac-address-blacklist property of the setting</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the</doc>
          <type name="GLib.SList" c:type="GSList*">
            <array name="GLib.ByteArray">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </type>
        </return-value>
      </method>
      <method name="get_mode" c:identifier="nm_setting_wireless_get_mode">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:mode property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_wireless_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_seen_bssids"
              c:identifier="nm_setting_wireless_get_num_seen_bssids">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of BSSIDs in the previously seen BSSID list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_rate" c:identifier="nm_setting_wireless_get_rate">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:rate property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_security"
              c:identifier="nm_setting_wireless_get_security">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:security property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_seen_bssid"
              c:identifier="nm_setting_wireless_get_seen_bssid">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the BSSID at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of a BSSID in the previously seen BSSID list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_setting_wireless_get_ssid">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:ssid property of the setting</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
      </method>
      <method name="get_tx_power"
              c:identifier="nm_setting_wireless_get_tx_power">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWireless:tx-power property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <property name="band" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">802.11 frequency band of the network.  One of 'a' for 5GHz 802.11a or
'bg' for 2.4GHz 802.11.  This will lock associations to the WiFi network
to the specific band, i.e. if 'a' is specified, the device will not
associate with the same network in the 2.4GHz band even if the network's
settings are compatible.  This setting depends on specific driver
capability and may not work with all drivers.</doc>
        <type name="utf8"/>
      </property>
      <property name="bssid"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, directs the device to only associate with the given access
point.  This capability is highly driver dependent and not supported by
all devices.  Note: this property does not control the BSSID used when
creating an Ad-Hoc network and is unlikely to in the future.</doc>
        <type/>
      </property>
      <property name="channel"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Wireless channel to use for the WiFi connection.  The device will only
join (or create for Ad-Hoc networks) a WiFi network on the specified
channel.  Because channel numbers overlap between bands, this property
also requires the 'band' property to be set.</doc>
        <type name="guint"/>
      </property>
      <property name="cloned-mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, request that the Wifi device use this MAC address instead of its
permanent MAC address.  This is known as MAC cloning or spoofing.</doc>
        <type/>
      </property>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, this connection will only apply to the WiFi device
whose permanent MAC address matches. This property does not change the MAC address
of the device (i.e. MAC spoofing).</doc>
        <type/>
      </property>
      <property name="mac-address-blacklist"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, this connection will never apply to the WiFi device
whose permanent MAC address matches an address in the list.  Each
MAC address is in the standard hex-digits-and-colons notation.
(00:11:22:33:44:55).</doc>
        <type/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">WiFi network mode; one of 'infrastructure' or 'adhoc'.  If blank,
infrastructure is assumed.</doc>
        <type name="utf8"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple Ethernet frames.</doc>
        <type name="guint"/>
      </property>
      <property name="rate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, directs the device to only use the specified bitrate for
communication with the access point.  Units are in Kb/s, ie 5500 = 5.5
Mbit/s.  This property is highly driver dependent and not all devices
support setting a static bitrate.</doc>
        <type name="guint"/>
      </property>
      <property name="security" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the wireless connection has any security restrictions, like 802.1x,
WEP, or WPA, set this property to '802-11-wireless-security' and ensure
the connection contains a valid 802-11-wireless-security setting.</doc>
        <type name="utf8"/>
      </property>
      <property name="seen-bssids"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A list of BSSIDs (each BSSID formatted as a MAC address like
'00:11:22:33:44:55') that have been detected as part of the WiFI network.
NetworkManager internally tracks previously seen BSSIDs so this property
is no longer of much use.</doc>
        <type/>
      </property>
      <property name="ssid"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">SSID of the WiFi network.</doc>
        <type/>
      </property>
      <property name="tx-power"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If non-zero, directs the device to use the specified transmit power.
Units are dBm.  This property is highly driver dependent and not all
devices support setting a static transmit power.</doc>
        <type name="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWirelessClass"
            c:type="NMSettingWirelessClass"
            glib:is-gtype-struct-for="SettingWireless">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingWirelessError"
                 glib:type-name="NMSettingWirelessError"
                 glib:get-type="nm_setting_wireless_error_get_type"
                 c:type="NMSettingWirelessError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIRELESS_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIRELESS_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIRELESS_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="MissingSecuritySetting"
              value="3"
              c:identifier="NM_SETTING_WIRELESS_ERROR_MISSING_SECURITY_SETTING"
              glib:nick="MissingSecuritySetting"/>
      <member name="ChannelRequiresBand"
              value="4"
              c:identifier="NM_SETTING_WIRELESS_ERROR_CHANNEL_REQUIRES_BAND"
              glib:nick="ChannelRequiresBand"/>
      <function name="quark" c:identifier="nm_setting_wireless_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMSettingWireless if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMSettingWireless errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWirelessSecurity"
           c:symbol-prefix="setting_wireless_security"
           c:type="NMSettingWirelessSecurity"
           parent="Setting"
           glib:type-name="NMSettingWirelessSecurity"
           glib:get-type="nm_setting_wireless_security_get_type"
           glib:type-struct="SettingWirelessSecurityClass">
      <constructor name="new" c:identifier="nm_setting_wireless_security_new">
        <doc xml:whitespace="preserve">Creates a new #NMSettingWirelessSecurity object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new empty #NMSettingWirelessSecurity object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_group"
              c:identifier="nm_setting_wireless_security_add_group">
        <doc xml:whitespace="preserve">Adds an encryption algorithm to the list of allowed groupwise encryption
algorithms.  If the list is not empty, then only access points that support
one or more of the encryption algorithms in the list will be considered
compatible with this connection.

already in the list</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the algorithm was added to the list, %FALSE if it was</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the encryption algorithm to add, one of "wep40", "wep104", "tkip", or "ccmp"</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_pairwise"
              c:identifier="nm_setting_wireless_security_add_pairwise">
        <doc xml:whitespace="preserve">Adds an encryption algorithm to the list of allowed pairwise encryption
algorithms.  If the list is not empty, then only access points that support
one or more of the encryption algorithms in the list will be considered
compatible with this connection.

already in the list</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the algorithm was added to the list, %FALSE if it was</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pairwise" transfer-ownership="none">
            <doc xml:whitespace="preserve">the encryption algorithm to add, one of "wep40", "wep104", "tkip", or "ccmp"</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_proto"
              c:identifier="nm_setting_wireless_security_add_proto">
        <doc xml:whitespace="preserve">Adds a WiFi security protocol (one of "wpa" or "rsn") to the allowed list;
only protocols in this list will be used when finding and connecting to
the WiFi network specified by this connection.  For example, if the
protocol list contains only "wpa" but the access point for the SSID specified
by this connection only supports WPA2/RSN, the connection cannot be used
with the access point.

protocol list, or %FALSE if it was already in the list</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the protocol was new and and was added to the allowed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:whitespace="preserve">the protocol to add, one of "wpa" or "rsn"</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_groups"
              c:identifier="nm_setting_wireless_security_clear_groups">
        <doc xml:whitespace="preserve">Removes all algorithms from the allowed list.  If there are no algorithms
specified then all groupwise encryption algorithms are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_pairwise"
              c:identifier="nm_setting_wireless_security_clear_pairwise">
        <doc xml:whitespace="preserve">Removes all algorithms from the allowed list.  If there are no algorithms
specified then all pairwise encryption algorithms are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="clear_protos"
              c:identifier="nm_setting_wireless_security_clear_protos">
        <doc xml:whitespace="preserve">Removes all protocols from the allowed list.  If there are no protocols
specified then all protocols are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_auth_alg"
              c:identifier="nm_setting_wireless_security_get_auth_alg">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:auth-alg property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_group"
              c:identifier="nm_setting_wireless_security_get_group">
        <doc xml:whitespace="preserve">Returns the allowed groupwise encryption algorithm from allowed algorithm
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the groupwise encryption algorithm at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of an item in the allowed groupwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_key_mgmt"
              c:identifier="nm_setting_wireless_security_get_key_mgmt">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:key-mgmt property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_leap_password"
              c:identifier="nm_setting_wireless_security_get_leap_password">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:leap-password property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_leap_password_flags"
              c:identifier="nm_setting_wireless_security_get_leap_password_flags">
        <doc xml:whitespace="preserve">#NMSettingWirelessSecurity:leap-password</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_leap_username"
              c:identifier="nm_setting_wireless_security_get_leap_username">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:leap-username property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_num_groups"
              c:identifier="nm_setting_wireless_security_get_num_groups">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of groupwise encryption algorithms in the allowed list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_pairwise"
              c:identifier="nm_setting_wireless_security_get_num_pairwise">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of pairwise encryption algorithms in the allowed list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_num_protos"
              c:identifier="nm_setting_wireless_security_get_num_protos">
        <doc xml:whitespace="preserve">connecting to secure WiFi networks</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of security protocols this connection allows when</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_pairwise"
              c:identifier="nm_setting_wireless_security_get_pairwise">
        <doc xml:whitespace="preserve">Returns the allowed pairwise encryption algorithm from allowed algorithm
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the pairwise encryption algorithm at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of an item in the allowed pairwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_proto"
              c:identifier="nm_setting_wireless_security_get_proto">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the protocol at index @i</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index into the protocol list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_psk"
              c:identifier="nm_setting_wireless_security_get_psk">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:psk property of the setting</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_psk_flags"
              c:identifier="nm_setting_wireless_security_get_psk_flags">
        <doc xml:whitespace="preserve">#NMSettingWirelessSecurity:psk</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_wep_key"
              c:identifier="nm_setting_wireless_security_get_wep_key">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the WEP key at the given index</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the WEP key index (0..3 inclusive)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_wep_key_flags"
              c:identifier="nm_setting_wireless_security_get_wep_key_flags">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingSecretFlags pertaining to the all WEP keys</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
      </method>
      <method name="get_wep_key_type"
              c:identifier="nm_setting_wireless_security_get_wep_key_type">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:wep-key-type property of the setting</doc>
          <type name="WepKeyType" c:type="NMWepKeyType"/>
        </return-value>
      </method>
      <method name="get_wep_tx_keyidx"
              c:identifier="nm_setting_wireless_security_get_wep_tx_keyidx">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMSettingWirelessSecurity:wep-tx-keyidx property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="remove_group"
              c:identifier="nm_setting_wireless_security_remove_group">
        <doc xml:whitespace="preserve">Removes an encryption algorithm from the allowed groupwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of an item in the allowed groupwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pairwise"
              c:identifier="nm_setting_wireless_security_remove_pairwise">
        <doc xml:whitespace="preserve">Removes an encryption algorithm from the allowed pairwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of an item in the allowed pairwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_proto"
              c:identifier="nm_setting_wireless_security_remove_proto">
        <doc xml:whitespace="preserve">Removes a protocol from the allowed protocol list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of the protocol to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_wep_key"
              c:identifier="nm_setting_wireless_security_set_wep_key">
        <doc xml:whitespace="preserve">Sets a WEP key in the given index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the key (0..3 inclusive)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the WEP key as a string, in either hexadecimal, ASCII, or passphrase form as determiend by the value of the #NMSettingWirelessSecurity:wep-key-type property.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auth-alg" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">When WEP is used (ie, key-mgmt = 'none' or 'ieee8021x') indicate the
802.11 authentication algorithm required by the AP here.  One of 'open'
for Open System, 'shared' for Shared Key, or 'leap' for Cisco LEAP.
When using Cisco LEAP (ie, key-mgmt = 'ieee8021x' and auth-alg = 'leap')
the 'leap-username' and 'leap-password' properties must be specified.</doc>
        <type name="utf8"/>
      </property>
      <property name="group"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, will only connect to WPA networks that provide the
specified group/multicast encryption capabilities.  Each element may be
one of 'wep40', 'wep104', 'tkip', or 'ccmp'.</doc>
        <type/>
      </property>
      <property name="key-mgmt" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Key management used for the connection.  One of 'none' (WEP), 'ieee8021x'
(Dynamic WEP), 'wpa-none' (Ad-Hoc WPA-PSK), 'wpa-psk' (infrastructure
WPA-PSK), or 'wpa-eap' (WPA-Enterprise).  This property must be set for
any WiFi connection that uses security.</doc>
        <type name="utf8"/>
      </property>
      <property name="leap-password" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The login password for legacy LEAP connections (ie, key-mgmt =
'ieee8021x' and auth-alg = 'leap').</doc>
        <type name="utf8"/>
      </property>
      <property name="leap-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingWirelessSecurity:leap-password.</doc>
        <type name="guint"/>
      </property>
      <property name="leap-username" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The login username for legacy LEAP connections (ie, key-mgmt =
'ieee8021x' and auth-alg = 'leap').</doc>
        <type name="utf8"/>
      </property>
      <property name="pairwise"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If specified, will only connect to WPA networks that provide the
specified pairwise encryption capabilities.  Each element may be one of
'wep40', 'wep104', 'tkip', or 'ccmp'.</doc>
        <type/>
      </property>
      <property name="proto"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">List of strings specifying the allowed WPA protocol versions to use.
Each element may be one 'wpa' (allow WPA) or 'rsn' (allow WPA2/RSN).  If
not specified, both WPA and RSN connections are allowed.</doc>
        <type/>
      </property>
      <property name="psk" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Pre-Shared-Key for WPA networks.  If the key is 64-characters long, it
must contain only hexadecimal characters and is interpreted as a
hexadecimal WPA key.  Otherwise, the key must be between 8 and 63 ASCII
characters (as specified in the 802.11i standard) and is interpreted as
a WPA passphrase, and is hashed to derive the actual WPA-PSK used when
connecting to the WiFi network.</doc>
        <type name="utf8"/>
      </property>
      <property name="psk-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingWirelessSecurity:psk</doc>
        <type name="guint"/>
      </property>
      <property name="wep-key-flags" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Flags indicating how to handle #NMSettingWirelessSecurity WEP keys.</doc>
        <type name="guint"/>
      </property>
      <property name="wep-key-type"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Controls the interpretation of WEP keys.  Allowed values are those given
by %NMWepKeyType.  If set to 1 and the keys are hexadecimal, they must be
either 10 or 26 characters in length.  If set to 1 and the keys are
ASCII keys, they must be either 5 or 13 characters in length.  If set to
2, the passphrase is hashed using the de-facto MD5 method to derive the
actual WEP key.</doc>
        <type name="guint"/>
      </property>
      <property name="wep-key0" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Index 0 WEP key.  This is the WEP key used in most networks.  See the
'wep-key-type' property for a description of how this key is interpreted.</doc>
        <type name="utf8"/>
      </property>
      <property name="wep-key1" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Index 1 WEP key.  This WEP index is not used by most networks.  See the
'wep-key-type' property for a description of how this key is interpreted.</doc>
        <type name="utf8"/>
      </property>
      <property name="wep-key2" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Index 2 WEP key.  This WEP index is not used by most networks.  See the
'wep-key-type' property for a description of how this key is interpreted.</doc>
        <type name="utf8"/>
      </property>
      <property name="wep-key3" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Index 3 WEP key.  This WEP index is not used by most networks.  See the
'wep-key-type' property for a description of how this key is interpreted.</doc>
        <type name="utf8"/>
      </property>
      <property name="wep-tx-keyidx"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When static WEP is used (ie, key-mgmt = 'none') and a non-default WEP key
index is used by the AP, put that WEP key index here.  Valid values are 0
(default key) through 3.  Note that some consumer access points (like the
Linksys WRT54G) number the keys 1 - 4.</doc>
        <type name="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWirelessSecurityClass"
            c:type="NMSettingWirelessSecurityClass"
            glib:is-gtype-struct-for="SettingWirelessSecurity">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingWirelessSecurityError"
                 glib:type-name="NMSettingWirelessSecurityError"
                 glib:get-type="nm_setting_wireless_security_error_get_type"
                 c:type="NMSettingWirelessSecurityError">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_UNKNOWN"
              glib:nick="UnknownError"/>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty"/>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty"/>
      <member name="Missing8021xSetting"
              value="3"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_MISSING_802_1X_SETTING"
              glib:nick="Missing8021xSetting"/>
      <member name="LEAPRequires8021x"
              value="4"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_LEAP_REQUIRES_802_1X"
              glib:nick="LEAPRequires8021x"/>
      <member name="LEAPRequiresUsername"
              value="5"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_LEAP_REQUIRES_USERNAME"
              glib:nick="LEAPRequiresUsername"/>
      <member name="SharedKeyRequiresWEP"
              value="6"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_SHARED_KEY_REQUIRES_WEP"
              glib:nick="SharedKeyRequiresWEP"/>
      <function name="quark"
                c:identifier="nm_setting_wireless_security_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="State" c:type="NMState">
      <doc xml:whitespace="preserve">#NMState values indicate the current overall networking state.</doc>
      <member name="unknown" value="0" c:identifier="NM_STATE_UNKNOWN"/>
      <member name="asleep" value="10" c:identifier="NM_STATE_ASLEEP"/>
      <member name="disconnected"
              value="20"
              c:identifier="NM_STATE_DISCONNECTED"/>
      <member name="disconnecting"
              value="30"
              c:identifier="NM_STATE_DISCONNECTING"/>
      <member name="connecting" value="40" c:identifier="NM_STATE_CONNECTING"/>
      <member name="connected_local"
              value="50"
              c:identifier="NM_STATE_CONNECTED_LOCAL"/>
      <member name="connected_site"
              value="60"
              c:identifier="NM_STATE_CONNECTED_SITE"/>
      <member name="connected_global"
              value="70"
              c:identifier="NM_STATE_CONNECTED_GLOBAL"/>
    </enumeration>
    <constant name="UTILS_HWADDR_LEN_MAX"
              value="20"
              c:type="NM_UTILS_HWADDR_LEN_MAX">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="UtilsSecurityType"
                 glib:type-name="NMUtilsSecurityType"
                 glib:get-type="nm_utils_security_type_get_type"
                 c:type="NMUtilsSecurityType">
      <doc xml:whitespace="preserve">Describes generic security mechanisms that 802.11 access points may offer.
Used with nm_utils_security_valid() for checking whether a given access
point is compatible with a network device.</doc>
      <member name="invalid"
              value="0"
              c:identifier="NMU_SEC_INVALID"
              glib:nick="invalid"/>
      <member name="none"
              value="1"
              c:identifier="NMU_SEC_NONE"
              glib:nick="none"/>
      <member name="static_wep"
              value="2"
              c:identifier="NMU_SEC_STATIC_WEP"
              glib:nick="static-wep"/>
      <member name="leap"
              value="3"
              c:identifier="NMU_SEC_LEAP"
              glib:nick="leap"/>
      <member name="dynamic_wep"
              value="4"
              c:identifier="NMU_SEC_DYNAMIC_WEP"
              glib:nick="dynamic-wep"/>
      <member name="wpa_psk"
              value="5"
              c:identifier="NMU_SEC_WPA_PSK"
              glib:nick="wpa-psk"/>
      <member name="wpa_enterprise"
              value="6"
              c:identifier="NMU_SEC_WPA_ENTERPRISE"
              glib:nick="wpa-enterprise"/>
      <member name="wpa2_psk"
              value="7"
              c:identifier="NMU_SEC_WPA2_PSK"
              glib:nick="wpa2-psk"/>
      <member name="wpa2_enterprise"
              value="8"
              c:identifier="NMU_SEC_WPA2_ENTERPRISE"
              glib:nick="wpa2-enterprise"/>
    </enumeration>
    <enumeration name="VPNConnectionState" c:type="NMVPNConnectionState">
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_CONNECTION_STATE_UNKNOWN"/>
      <member name="prepare"
              value="1"
              c:identifier="NM_VPN_CONNECTION_STATE_PREPARE"/>
      <member name="need_auth"
              value="2"
              c:identifier="NM_VPN_CONNECTION_STATE_NEED_AUTH"/>
      <member name="connect"
              value="3"
              c:identifier="NM_VPN_CONNECTION_STATE_CONNECT"/>
      <member name="ip_config_get"
              value="4"
              c:identifier="NM_VPN_CONNECTION_STATE_IP_CONFIG_GET"/>
      <member name="activated"
              value="5"
              c:identifier="NM_VPN_CONNECTION_STATE_ACTIVATED"/>
      <member name="failed"
              value="6"
              c:identifier="NM_VPN_CONNECTION_STATE_FAILED"/>
      <member name="disconnected"
              value="7"
              c:identifier="NM_VPN_CONNECTION_STATE_DISCONNECTED"/>
    </enumeration>
    <enumeration name="VPNConnectionStateReason"
                 c:type="NMVPNConnectionStateReason">
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_UNKNOWN"/>
      <member name="none"
              value="1"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_NONE"/>
      <member name="user_disconnected"
              value="2"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED"/>
      <member name="device_disconnected"
              value="3"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED"/>
      <member name="service_stopped"
              value="4"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED"/>
      <member name="ip_config_invalid"
              value="5"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID"/>
      <member name="connect_timeout"
              value="6"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT"/>
      <member name="service_start_timeout"
              value="7"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT"/>
      <member name="service_start_failed"
              value="8"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED"/>
      <member name="no_secrets"
              value="9"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS"/>
      <member name="login_failed"
              value="10"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED"/>
      <member name="connection_removed"
              value="11"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED"/>
    </enumeration>
    <callback name="VPNIterFunc" c:type="NMVPNIterFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the data or secret item</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the data or secret item</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">User data passed to nm_setting_vpn_foreach_data_item() or nm_setting_vpn_foreach_secret()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="VPNPluginFailure" c:type="NMVPNPluginFailure">
      <member name="login_failed"
              value="0"
              c:identifier="NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED"/>
      <member name="connect_failed"
              value="1"
              c:identifier="NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED"/>
      <member name="bad_ip_config"
              value="2"
              c:identifier="NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG"/>
    </enumeration>
    <enumeration name="VPNServiceState" c:type="NMVPNServiceState">
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_SERVICE_STATE_UNKNOWN"/>
      <member name="init" value="1" c:identifier="NM_VPN_SERVICE_STATE_INIT"/>
      <member name="shutdown"
              value="2"
              c:identifier="NM_VPN_SERVICE_STATE_SHUTDOWN"/>
      <member name="starting"
              value="3"
              c:identifier="NM_VPN_SERVICE_STATE_STARTING"/>
      <member name="started"
              value="4"
              c:identifier="NM_VPN_SERVICE_STATE_STARTED"/>
      <member name="stopping"
              value="5"
              c:identifier="NM_VPN_SERVICE_STATE_STOPPING"/>
      <member name="stopped"
              value="6"
              c:identifier="NM_VPN_SERVICE_STATE_STOPPED"/>
    </enumeration>
    <constant name="VPN_DBUS_PLUGIN_INTERFACE"
              value="org.freedesktop.NetworkManager.VPN.Plugin"
              c:type="NM_VPN_DBUS_PLUGIN_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_DBUS_PLUGIN_PATH"
              value="/org/freedesktop/NetworkManager/VPN/Plugin"
              c:type="NM_VPN_DBUS_PLUGIN_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_ADDRESS"
              value="address"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_BANNER"
              value="banner"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DNS"
              value="dns"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DOMAIN"
              value="domain"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_EXT_GATEWAY"
              value="gateway"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_EXT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY"
              value="internal-gateway"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_MSS"
              value="mss"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_MSS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_MTU"
              value="mtu"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_NBNS"
              value="nbns"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_NBNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PREFIX"
              value="prefix"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PTP"
              value="ptp"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PTP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_TUNDEV"
              value="tundev"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_TUNDEV">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="VlanFlags"
                 glib:type-name="NMVlanFlags"
                 glib:get-type="nm_vlan_flags_get_type"
                 c:type="NMVlanFlags">
      <doc xml:whitespace="preserve">#NMVlanFlags values control the behavior of the VLAN interface.</doc>
      <member name="reorder_headers"
              value="1"
              c:identifier="NM_VLAN_FLAG_REORDER_HEADERS"
              glib:nick="reorder-headers"/>
      <member name="gvrp"
              value="2"
              c:identifier="NM_VLAN_FLAG_GVRP"
              glib:nick="gvrp"/>
      <member name="loose_binding"
              value="4"
              c:identifier="NM_VLAN_FLAG_LOOSE_BINDING"
              glib:nick="loose-binding"/>
    </enumeration>
    <enumeration name="VlanPriorityMap"
                 glib:type-name="NMVlanPriorityMap"
                 glib:get-type="nm_vlan_priority_map_get_type"
                 c:type="NMVlanPriorityMap">
      <doc xml:whitespace="preserve">A selector for traffic priority maps; these map Linux SKB priorities
to 802.1p priorities used in VLANs.</doc>
      <member name="ingress_map"
              value="0"
              c:identifier="NM_VLAN_INGRESS_MAP"
              glib:nick="ingress-map"/>
      <member name="egress_map"
              value="1"
              c:identifier="NM_VLAN_EGRESS_MAP"
              glib:nick="egress-map"/>
    </enumeration>
    <enumeration name="WepKeyType"
                 glib:type-name="NMWepKeyType"
                 glib:get-type="nm_wep_key_type_get_type"
                 c:type="NMWepKeyType">
      <doc xml:whitespace="preserve">The #NMWepKeyType values specify how any WEP keys present in the setting
are intepreted.  There are no standards governing how to hash the various WEP
key/passphrase formats into the actual WEP key.  Unfortunately some WEP keys
can be interpreted in multiple ways, requring the setting to specify how to
interpret the any WEP keys.  For example, the key "732f2d712e4a394a375d366931"
is both a valid Hexadecimal WEP key and a WEP passphrase.  Further, many
ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
keys are hashed differently to determine the actual WEP key the type must be
specified.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_WEP_KEY_TYPE_UNKNOWN"
              glib:nick="unknown"/>
      <member name="key"
              value="1"
              c:identifier="NM_WEP_KEY_TYPE_KEY"
              glib:nick="key"/>
      <member name="passphrase"
              value="2"
              c:identifier="NM_WEP_KEY_TYPE_PASSPHRASE"
              glib:nick="passphrase"/>
      <member name="last"
              value="2"
              c:identifier="NM_WEP_KEY_TYPE_LAST"
              glib:nick="last"/>
    </enumeration>
    <function name="connection_error_quark"
              c:identifier="nm_connection_error_quark"
              moved-to="ConnectionError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMConnection if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMConnection errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_802_1x_error_quark"
              c:identifier="nm_setting_802_1x_error_quark"
              moved-to="Setting8021xError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSetting8021x if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSetting8021x errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_bluetooth_error_quark"
              c:identifier="nm_setting_bluetooth_error_quark"
              moved-to="SettingBluetoothError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingBluetooth if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingBluetooth errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_bond_error_quark"
              c:identifier="nm_setting_bond_error_quark"
              moved-to="SettingBondError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingBond if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingBond errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_cdma_error_quark"
              c:identifier="nm_setting_cdma_error_quark"
              moved-to="SettingCdmaError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingCdma if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingCdma errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_connection_error_quark"
              c:identifier="nm_setting_connection_error_quark"
              moved-to="SettingConnectionError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingConnection if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingConnection errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_error_quark"
              c:identifier="nm_setting_error_quark"
              moved-to="SettingError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSetting if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for NMSetting errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_gsm_error_quark"
              c:identifier="nm_setting_gsm_error_quark"
              moved-to="SettingGsmError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingGsm if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingGsm errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_infiniband_error_quark"
              c:identifier="nm_setting_infiniband_error_quark"
              moved-to="SettingInfinibandError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingInfiniband if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingInfiniband errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_ip4_config_error_quark"
              c:identifier="nm_setting_ip4_config_error_quark"
              moved-to="SettingIP4ConfigError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingIP4Config if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingIP4Config errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_ip6_config_error_quark"
              c:identifier="nm_setting_ip6_config_error_quark"
              moved-to="SettingIP6ConfigError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingIP6Config if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingIP6Config errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_olpc_mesh_error_quark"
              c:identifier="nm_setting_olpc_mesh_error_quark"
              moved-to="SettingOlpcMeshError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_ppp_error_quark"
              c:identifier="nm_setting_ppp_error_quark"
              moved-to="SettingPPPError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingPPP if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingPPP errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_pppoe_error_quark"
              c:identifier="nm_setting_pppoe_error_quark"
              moved-to="SettingPPPOEError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingPPPOE if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingPPPOE errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_serial_error_quark"
              c:identifier="nm_setting_serial_error_quark"
              moved-to="SettingSerialError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingSerial if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingSerial errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_vlan_error_quark"
              c:identifier="nm_setting_vlan_error_quark"
              moved-to="SettingVlanError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingVlan if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingVlan errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_vpn_error_quark"
              c:identifier="nm_setting_vpn_error_quark"
              moved-to="SettingVpnError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingVPN if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingVPN errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wimax_error_quark"
              c:identifier="nm_setting_wimax_error_quark"
              moved-to="SettingWimaxError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingWimax if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingWimax errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wired_error_quark"
              c:identifier="nm_setting_wired_error_quark"
              moved-to="SettingWiredError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingWired if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingWired errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wireless_error_quark"
              c:identifier="nm_setting_wireless_error_quark"
              moved-to="SettingWirelessError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMSettingWireless if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMSettingWireless errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wireless_security_error_quark"
              c:identifier="nm_setting_wireless_security_error_quark"
              moved-to="SettingWirelessSecurityError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="utils_deinit" c:identifier="nm_utils_deinit">
      <doc xml:whitespace="preserve">Frees all resources used internally by libnm-util.  This function is called
from an atexit() handler, set up by nm_utils_init(), but is safe to be called
more than once.  Subsequent calls have no effect until nm_utils_init() is
called again.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="utils_escape_ssid" c:identifier="nm_utils_escape_ssid">
      <doc xml:whitespace="preserve">This function does a quick printable character conversion of the SSID, simply
replacing embedded NULLs and non-printable characters with the hexadecimal
representation of that character.  Intended for debugging only, should not
be used for display of SSIDs.

and will be overwritten by subsequent calls to this function</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">pointer to the escaped SSID, which uses an internal static buffer</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a buffer containing the SSID data</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">length of the SSID data in @ssid</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_gvalue_hash_dup"
              c:identifier="nm_utils_gvalue_hash_dup">
      <doc xml:whitespace="preserve">Utility function to duplicate a hash table of GValues.

returned hash with g_hash_table_unref() or g_hash_table_destroy()</doc>
      <return-value transfer-ownership="container">
        <doc xml:whitespace="preserve">a newly allocated duplicated #GHashTable, caller must free the</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable mapping string:GValue</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_atoba" c:identifier="nm_utils_hwaddr_atoba">
      <doc xml:whitespace="preserve">Parses @asc and converts it to binary form in a #GByteArray. See
nm_utils_hwaddr_aton() if you don't want a #GByteArray.

be parsed</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GByteArray, or %NULL if @asc couldn't</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:whitespace="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of address; either %ARPHRD_ETHER or %ARPHRD_INFINIBAND</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_aton" c:identifier="nm_utils_hwaddr_aton">
      <doc xml:whitespace="preserve">Parses @asc and converts it to binary form in @buffer. See
nm_utils_hwaddr_atoba() if you'd rather have the result in a
#GByteArray.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@buffer, or %NULL if @asc couldn't be parsed</doc>
        <type name="guint8" c:type="guint8*"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:whitespace="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of address; either %ARPHRD_ETHER or %ARPHRD_INFINIBAND</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">buffer to store the result into</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_len" c:identifier="nm_utils_hwaddr_len">
      <doc xml:whitespace="preserve">Returns the length in octets of a hardware address of type @type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the length</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of address; either %ARPHRD_ETHER or %ARPHRD_INFINIBAND</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_ntoa" c:identifier="nm_utils_hwaddr_ntoa">
      <doc xml:whitespace="preserve">Converts @addr to textual form.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the textual form of @addr</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="addr" transfer-ownership="none">
          <doc xml:whitespace="preserve">a binary hardware address</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of address; either %ARPHRD_ETHER or %ARPHRD_INFINIBAND</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_type" c:identifier="nm_utils_hwaddr_type">
      <doc xml:whitespace="preserve">Returns the type (either %ARPHRD_ETHER or %ARPHRD_INFINIBAND) of the raw
address given its length.

the address length was not recognized</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the type, either %ARPHRD_ETHER or %ARPHRD_INFINIBAND, or -1 if</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of hardware address in bytes</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_init" c:identifier="nm_utils_init" throws="1">
      <doc xml:whitespace="preserve">Initializes libnm-util; should be called when starting and program that
uses libnm-util.  Sets up an atexit() handler to ensure de-initialization
is performed, but calling nm_utils_deinit() to explicitly deinitialize
libnm-util can also be done.  This function can be called more than once.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the initialization was successful, FALSE on failure.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="utils_ip4_addresses_from_gvalue"
              c:identifier="nm_utils_ip4_addresses_from_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a #GPtrArray of #GArrays of guint32s representing
a list of NetworkManager IPv4 addresses (which is a tuple of address, gateway,
and prefix) into a GSList of #NMIP4Address objects.  The specific format of
this serialization is not guaranteed to be stable and the #GArray may be
extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GSList of #NMIP4Address objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP4Address"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">gvalue containing a GPtrArray of GArrays of guint32s</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_addresses_to_gvalue"
              c:identifier="nm_utils_ip4_addresses_to_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a #GSList of #NMIP4Address objects into a
GPtrArray of GArrays of guint32s representing a list of NetworkManager IPv4
addresses (which is a tuple of address, gateway, and prefix).   The specific
format of this serialization is not guaranteed to be stable and may be
extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of #NMIP4Address objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP4Address"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #GValue into which to place the converted addresses, which should be unset by the caller (when no longer needed) with g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_get_default_prefix"
              c:identifier="nm_utils_ip4_get_default_prefix">
      <doc xml:whitespace="preserve">When the Internet was originally set up, various ranges of IP addresses were
segmented into three network classes: A, B, and C.  This function will return
a prefix that is associated with the IP address specified defining where it
falls in the predefined classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the default class prefix for the given IP</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="ip" transfer-ownership="none">
          <doc xml:whitespace="preserve">an IPv4 address (in network byte order)</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_netmask_to_prefix"
              c:identifier="nm_utils_ip4_netmask_to_prefix">
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the CIDR prefix represented by the netmask</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="netmask" transfer-ownership="none">
          <doc xml:whitespace="preserve">an IPv4 netmask in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_prefix_to_netmask"
              c:identifier="nm_utils_ip4_prefix_to_netmask">
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the netmask represented by the prefix</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="prefix" transfer-ownership="none">
          <doc xml:whitespace="preserve">a CIDR prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_routes_from_gvalue"
              c:identifier="nm_utils_ip4_routes_from_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a GPtrArray of GArrays of guint32s representing
a list of NetworkManager IPv4 routes (which is a tuple of route, next hop,
prefix, and metric) into a GSList of #NMIP4Route objects.  The specific
format of this serialization is not guaranteed to be stable and may be
extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GSList of #NMIP4Route objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP4Route"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">gvalue containing a GPtrArray of GArrays of guint32s</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_routes_to_gvalue"
              c:identifier="nm_utils_ip4_routes_to_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a #GSList of #NMIP4Route objects into a
GPtrArray of GArrays of guint32s representing a list of NetworkManager IPv4
routes (which is a tuple of route, next hop, prefix, and metric).   The
specific format of this serialization is not guaranteed to be stable and may
be extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of #NMIP4Route objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP4Route"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #GValue into which to place the converted routes, which should be unset by the caller (when no longer needed) with g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_addresses_from_gvalue"
              c:identifier="nm_utils_ip6_addresses_from_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a #GPtrArray of #GValueArrays of (#GArray of guchars) and guint32
representing a list of NetworkManager IPv6 addresses (which is a tuple of address,
prefix, and gateway), into a GSList of #NMIP6Address objects.  The specific format of
this serialization is not guaranteed to be stable and the #GValueArray may be
extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GSList of #NMIP6Address objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP6Address"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">gvalue containing a GPtrArray of GValueArrays of (GArray of guchars) and guint32</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_addresses_to_gvalue"
              c:identifier="nm_utils_ip6_addresses_to_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a #GSList of #NMIP6Address objects into a
GPtrArray of GValueArrays representing a list of NetworkManager IPv6 addresses
(which is a tuple of address, prefix, and gateway). The specific format of
this serialization is not guaranteed to be stable and may be extended in the
future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of #NMIP6Address objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP6Address"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #GValue into which to place the converted addresses, which should be unset by the caller (when no longer needed) with g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_dns_from_gvalue"
              c:identifier="nm_utils_ip6_dns_from_gvalue"
              introspectable="0">
      <doc xml:whitespace="preserve">Converts a #GValue containing a #GPtrArray of IP6 DNS, represented as
#GByteArray&lt;!-- --&gt;s into a #GSList of #in6_addr&lt;!-- --&gt;s.

addresses.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #GSList of IP6</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="Posix.in6_addr"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_dns_to_gvalue"
              c:identifier="nm_utils_ip6_dns_to_gvalue"
              introspectable="0">
      <doc xml:whitespace="preserve">Utility function to convert a #GSList of 'struct in6_addr' structs into a
GPtrArray of GByteArrays representing each server's IPv6 addresses in
network byte order.  The specific format of this serialization is not
guaranteed to be stable and may be extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of #NMIP6Route objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #GValue into which to place the converted DNS server addresses, which should be unset by the caller (when no longer needed) with g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_routes_from_gvalue"
              c:identifier="nm_utils_ip6_routes_from_gvalue">
      <doc xml:whitespace="preserve">Utility function GPtrArray of GValueArrays of (GArray or guchars), guint32,
(GArray of guchars), and guint32 representing a list of NetworkManager IPv6
routes (which is a tuple of destination, prefix, next hop, and metric)
into a GSList of #NMIP6Route objects.  The specific format of this serialization
is not guaranteed to be stable and may be extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GSList of #NMIP6Route objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP6Route"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">gvalue containing a GPtrArray of GValueArrays of (GArray or guchars), guint32, (GArray of guchars), and guint32</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_routes_to_gvalue"
              c:identifier="nm_utils_ip6_routes_to_gvalue">
      <doc xml:whitespace="preserve">Utility function to convert a #GSList of #NMIP6Route objects into a GPtrArray of
GValueArrays of (GArray or guchars), guint32, (GArray of guchars), and guint32
representing a list of NetworkManager IPv6 routes (which is a tuple of destination,
prefix, next hop, and metric).  The specific format of this serialization is not 
guaranteed to be stable and may be extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of #NMIP6Route objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP6Route"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #GValue into which to place the converted routes, which should be unset by the caller (when no longer needed) with g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_empty_ssid" c:identifier="nm_utils_is_empty_ssid">
      <doc xml:whitespace="preserve">Different manufacturers use different mechanisms for not broadcasting the
AP's SSID.  This function attempts to detect blank/empty SSIDs using a
number of known SSID-cloaking methods.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the SSID is "empty", FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a buffer containing the SSID data</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">length of the SSID data in @ssid</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_rsa_key_encrypt"
              c:identifier="nm_utils_rsa_key_encrypt"
              throws="1">
      <doc xml:whitespace="preserve">Encrypts the given RSA private key data with the given password (or generates
a password if no password was given) and converts the data to PEM format
suitable for writing to a file.

certificate/private key file.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">on success, PEM-formatted data suitable for writing to a PEM-formatted</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">RSA private key data to be encrypted</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="in_password" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">existing password to use, if any</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out_password"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">if @in_password was NULL, a random password will be generated and returned in this argument</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_same_ssid" c:identifier="nm_utils_same_ssid">
      <doc xml:whitespace="preserve">Earlier versions of the Linux kernel added a NULL byte to the end of the
SSID to enable easy printing of the SSID on the console or in a terminal,
but this behavior was problematic (SSIDs are simply byte arrays, not strings)
and thus was changed.  This function compensates for that behavior at the
cost of some compatibility with odd SSIDs that may legitimately have trailing
NULLs, even though that is functionally pointless.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the SSIDs are the same, FALSE if they are not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ssid1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first SSID data to compare</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="ssid2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second SSID data to compare</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="ignore_trailing_null" transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE to ignore one trailing NULL byte</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_security_valid"
              c:identifier="nm_utils_security_valid">
      <doc xml:whitespace="preserve">Given a set of device capabilities, and a desired security type to check
against, determines whether the combination of device, desired security
type, and AP capabilities intersect.

compatible with the desired @type, FALSE if they are not</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the device capabilities and AP capabilties intersect and are</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the security type to check AP flags and device capabilties against, e.g. #NMU_SEC_STATIC_WEP</doc>
          <type name="UtilsSecurityType" c:type="NMUtilsSecurityType"/>
        </parameter>
        <parameter name="wifi_caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">bitfield of the capabilities of the specific WiFi device, e.g. #NM_WIFI_DEVICE_CAP_CIPHER_WEP40</doc>
          <type name="DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </parameter>
        <parameter name="have_ap" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the @ap_flags, @ap_wpa, and @ap_rsn arguments are valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="adhoc" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the capabilities being tested are from an Ad-Hoc AP (IBSS)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="ap_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">bitfield of AP capabilities, e.g. #NM_802_11_AP_FLAGS_PRIVACY</doc>
          <type name="80211ApFlags" c:type="NM80211ApFlags"/>
        </parameter>
        <parameter name="ap_wpa" transfer-ownership="none">
          <doc xml:whitespace="preserve">bitfield of AP capabilties derived from the AP's WPA beacon, e.g. (#NM_802_11_AP_SEC_PAIR_TKIP | #NM_802_11_AP_SEC_KEY_MGMT_PSK)</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </parameter>
        <parameter name="ap_rsn" transfer-ownership="none">
          <doc xml:whitespace="preserve">bitfield of AP capabilties derived from the AP's RSN/WPA2 beacon, e.g. (#NM_802_11_AP_SEC_PAIR_CCMP | #NM_802_11_AP_SEC_PAIR_TKIP)</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_slist_free"
              c:identifier="nm_utils_slist_free"
              introspectable="0">
      <doc xml:whitespace="preserve">Utility function to free a #GSList.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="elem_destroy_fn"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:whitespace="preserve">user function called for each element in @list</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ssid_to_utf8" c:identifier="nm_utils_ssid_to_utf8">
      <doc xml:whitespace="preserve">WiFi SSIDs are byte arrays, they are _not_ strings.  Thus, an SSID may
contain embedded NULLs and other unprintable characters.  Often it is
useful to print the SSID out for debugging purposes, but that should be the
_only_ use of this function.  Do not use this function for any persistent
storage of the SSID, since the printable SSID returned from this function
cannot be converted back into the real SSID of the access point.

This function does almost everything humanly possible to convert the input
into a printable UTF-8 string, using roughly the following procedure:

1) if the input data is already UTF-8 safe, no conversion is performed
2) attempts to get the current system language from the LANG environment
variable, and depending on the language, uses a table of alternative
encodings to try.  For example, if LANG=hu_HU, the table may first try
the ISO-8859-2 encoding, and if that fails, try the Windows-1250 encoding.
If all fallback encodings fail, replaces non-UTF-8 characters with '?'.
3) If the system language was unable to be determined, falls back to the
ISO-8859-1 encoding, then to the Windows-1251 encoding.
4) If step 3 fails, replaces non-UTF-8 characters with '?'.

Again, this function should be used for debugging and display purposes
_only_.

representation of the SSID, which must be freed by the caller using g_free().
Returns NULL on errors.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">an allocated string containing a UTF-8</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:whitespace="preserve">a byte array containing the SSID data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utils_uuid_generate" c:identifier="nm_utils_uuid_generate">
      <doc xml:whitespace="preserve">object's #NMSettingConnection:id: property.  Should be freed with g_free()</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated UUID suitable for use as the #NMSettingConnection</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="utils_uuid_generate_from_string"
              c:identifier="nm_utils_uuid_generate_from_string">
      <doc xml:whitespace="preserve">For a given @s, this function will always return the same UUID.

object's #NMSettingConnection:id: property</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated UUID suitable for use as the #NMSettingConnection</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="s" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string to use as the seed for the UUID</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_channel_to_freq"
              c:identifier="nm_utils_wifi_channel_to_freq">
      <doc xml:whitespace="preserve">Utility function to translate a WiFi channel to its corresponding frequency.

or -1 when the freq is invalid, or 0 when the band
is invalid</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the frequency represented by the channel of the band,</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_find_next_channel"
              c:identifier="nm_utils_wifi_find_next_channel">
      <doc xml:whitespace="preserve">Utility function to find out next/previous WiFi channel for a channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the next channel in the specified direction or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">current channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether going downward (0 or less) or upward (1 or more)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_freq_to_channel"
              c:identifier="nm_utils_wifi_freq_to_channel">
      <doc xml:whitespace="preserve">Utility function to translate a WiFi frequency to its corresponding channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the channel represented by the frequency or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="freq" transfer-ownership="none">
          <doc xml:whitespace="preserve">frequency</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_is_channel_valid"
              c:identifier="nm_utils_wifi_is_channel_valid">
      <doc xml:whitespace="preserve">Utility function to verify WiFi channel validity.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE or FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
